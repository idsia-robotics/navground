import datetime
import pathlib
from typing import Callable, ClassVar, Literal, TypeAlias, overload

import navground.core._navground
import numpy

Vector2: TypeAlias = numpy.ndarray[tuple[Literal[2]], numpy.dtype[numpy.float64]]

class Agent(NativeAgent):
    behavior: navground.core._navground.Behavior
    kinematics: navground.core._navground.Kinematics
    state_estimation: StateEstimation
    task: Task
    def __init__(self, radius: float = ..., behavior: navground.core._navground.Behavior | None = ..., kinematics: navground.core._navground.Kinematics | None = ..., task: Task | None = ..., state_estimation: StateEstimation | None = ..., control_period: float = ..., id: int = ...) -> None: ...
    @property
    def controller(self) -> navground.core._navground.Controller: ...

class AntipodalScenario(Scenario):
    orientation_noise: float
    position_noise: float
    radius: float
    tolerance: float
    def __init__(self, radius: float = ..., tolerance: float = ..., position_noise: float = ..., orientation_noise: float = ..., shuffle: bool = ...) -> None: ...

class BoundarySensor(Sensor):
    max_x: float
    max_y: float
    min_x: float
    min_y: float
    range: float
    def __init__(self, range: float = ..., min_x: float = ..., max_x: float = ..., min_y: float = ..., max_y: float = ...) -> None: ...

class BoundedStateEstimation(StateEstimation):
    range: float
    update_static_obstacles: bool
    def __init__(self, range: float = ..., update_static_obstacles: bool = ..., name: str = ...) -> None: ...
    def _neighbors_of_agent(self, agent: Agent, world: World) -> list[navground.core._navground.Neighbor]: ...

class BoundingBox:
    @overload
    def __init__(self, min_x: float, max_x: float, min_y: float, max_y: float) -> None: ...
    @overload
    def __init__(self, p1: Vector2, p2: Vector2) -> None: ...
    @property
    def max_x(self) -> float: ...
    @property
    def max_y(self) -> float: ...
    @property
    def min_x(self) -> float: ...
    @property
    def min_y(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...

class CorridorScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    length: float
    width: float
    def __init__(self, width: float = ..., length: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ...) -> None: ...

class CrossScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    target_margin: float
    tolerance: float
    def __init__(self, side: float = ..., tolerance: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ..., target_margin: float = ...) -> None: ...

class CrossTorusScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    def __init__(self, side: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ...) -> None: ...

class Dataset:
    dtype: numpy.dtype
    item_shape: list[int]
    @overload
    def __init__(self, data: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, dtype: object, item_shape: list[int] = ...) -> None: ...
    @overload
    def append(self, values: numpy.ndarray, reset: bool = ...) -> None: ...
    @overload
    def append(self, values: list[float] | list[float] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int]) -> None: ...
    def push(self, value: float | float | int | int | int | int | int | int | int | int) -> None: ...
    def reset(self) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __iter__(self) -> object: ...
    def __len__(self) -> int: ...
    def __release_buffer__(self, *args, **kwargs): ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def size(self) -> int: ...

class DirectionTask(Task):
    direction: Vector2
    def __init__(self, direction: Vector2 = ...) -> None: ...

class DiscsStateEstimation(Sensor):
    include_valid: bool
    max_id: int
    max_radius: float
    max_speed: float
    number: int
    range: float
    use_nearest_point: bool
    def __init__(self, range: float = ..., number: int = ..., max_radius: float = ..., max_speed: float = ..., include_valid: bool = ..., use_nearest_point: bool = ..., max_id: int = ..., name: str = ...) -> None: ...

class Entity:
    def __init__(self, *args, **kwargs) -> None: ...
    def has_been_in_collision_since(self, time: float) -> bool: ...
    @property
    def _uid(self) -> int: ...
    @property
    def last_collision_time(self) -> float: ...

class Experiment:
    run_mp: ClassVar[Callable] = ...
    setup_tqdm: ClassVar[Callable] = ...
    _group_record_probes: dict[str, Callable[[], GroupRecordProbe]]
    _probes: list[Callable[[], Probe]]
    _record_probes: dict[str, Callable[[], RecordProbe]]
    name: str
    number_of_runs: int
    record_config: RecordConfig
    run_callbacks: dict[bool, list[Callable[[ExperimentalRun], None]]]
    run_index: int
    save_directory: pathlib.Path
    scenario: Scenario
    scenario_init_callback: Callable[[Scenario, int], None] | None
    steps: int
    terminate_when_all_idle_or_stuck: bool
    time_step: float
    def __init__(self, time_step: float = ..., steps: int = ...) -> None: ...
    def add_group_record_probe(self, key: str, probe_cls: object) -> None: ...
    def add_probe(self, factory: object) -> None: ...
    def add_record_probe(self, key: str, probe_cls: object) -> None: ...
    def add_run(self, seed: int, run: ExperimentalRun) -> None: ...
    def add_run_callback(self, callback: Callable[[ExperimentalRun], None], at_init: bool = ...) -> None: ...
    def clear_run_callbacks(self) -> None: ...
    def get_run(self, arg0: int) -> ExperimentalRun: ...
    def init_run(self, seed: int, world: World = ...) -> ExperimentalRun: ...
    def remove_all_runs(self) -> None: ...
    def remove_run(self, seed: int) -> None: ...
    def run(self, keep: bool = ..., number_of_threads: int = ..., start_index: int | None = ..., number_of_runs: int | None = ..., data_path: pathlib.Path | None = ...) -> None: ...
    def run_once(self, seed: int) -> ExperimentalRun: ...
    def save(self, directory: pathlib.Path | None = ..., path: pathlib.Path | None = ...) -> None: ...
    def start(self, path: pathlib.Path | None = ...) -> None: ...
    def start_run(self, run: ExperimentalRun) -> None: ...
    def stop(self, save_runs: bool = ...) -> None: ...
    def stop_run(self, run: ExperimentalRun) -> None: ...
    def update_run(self, run: ExperimentalRun) -> None: ...
    @property
    def begin_time(self) -> datetime.datetime: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def is_running(self) -> bool: ...
    @property
    def path(self) -> pathlib.Path | None: ...
    @property
    def runs(self) -> dict[int, ExperimentalRun]: ...

class ExperimentalRun:
    def __init__(self, world: World, time_step: float = ..., steps: int = ..., terminate_when_all_idle_or_stuck: bool = ..., record_config: RecordConfig = ..., seed: int = ...) -> None: ...
    def add_group_record_probe(self, key: str, probe_cls: object) -> GroupRecordProbe: ...
    def add_probe(self, probe: Probe) -> None: ...
    @overload
    def add_record(self, key: str, data: numpy.ndarray) -> Dataset: ...
    @overload
    def add_record(self, key: str, dtype: object, item_shape: list[int] = ...) -> Dataset: ...
    def add_record_probe(self, key: str, probe_cls: object) -> RecordProbe: ...
    def get_collision_events(self, min_interval: int = ...) -> Dataset: ...
    def get_collisions_at_step(self, step: int) -> set[tuple[Entity, Entity]]: ...
    def get_record(self, key: str = ...) -> Dataset: ...
    def get_record_names(self, group: str = ...) -> set[str]: ...
    def get_records(self, group: str = ...) -> dict[str, Dataset]: ...
    def get_task_events(self, agent: Agent) -> numpy.ndarray: ...
    def go_to_step(self, step: int, ignore_collisions: bool = ..., ignore_twists: bool = ..., ignore_cmds: bool = ...) -> bool: ...
    def index_of_agent(self, agent: Agent) -> int | None: ...
    def reset(self) -> None: ...
    def run(self) -> None: ...
    @property
    def actuated_commands(self) -> numpy.ndarray: ...
    @property
    def bounding_box(self) -> BoundingBox: ...
    @property
    def collisions(self) -> numpy.ndarray: ...
    @property
    def commands(self) -> numpy.ndarray: ...
    @property
    def deadlocks(self) -> numpy.ndarray: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def efficacy(self) -> numpy.ndarray: ...
    @property
    def final_sim_time(self) -> float: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def maximal_steps(self) -> int: ...
    @property
    def neighbors(self) -> numpy.ndarray: ...
    @property
    def poses(self) -> numpy.ndarray: ...
    @property
    def record_config(self) -> RecordConfig: ...
    @property
    def record_names(self) -> set[str]: ...
    @property
    def recorded_steps(self) -> int: ...
    @property
    def records(self) -> dict[str, Dataset]: ...
    @property
    def safety_violations(self) -> numpy.ndarray: ...
    @property
    def seed(self) -> int: ...
    @property
    def targets(self) -> numpy.ndarray: ...
    @property
    def task_events(self) -> dict[int, numpy.ndarray]: ...
    @property
    def terminate_when_all_idle_or_stuck(self) -> bool: ...
    @property
    def time_step(self) -> float: ...
    @property
    def times(self) -> numpy.ndarray: ...
    @property
    def twists(self) -> numpy.ndarray: ...
    @property
    def world(self) -> World: ...

class GroupRecordProbe(Probe):
    def __init__(self, factory: Callable[[str], Dataset] | None = ...) -> None: ...
    def get_data(self, key: str) -> Dataset: ...

class LidarStateEstimation(Sensor):
    error_bias: float
    error_std_dev: float
    field_of_view: float
    position: Vector2
    range: float
    resolution: int
    start_angle: float
    def __init__(self, range: float = ..., start_angle: float = ..., field_of_view: float = ..., resolution: int = ..., position: Vector2 = ..., error_bias: float = ..., error_std_dev: float = ..., name: str = ...) -> None: ...
    @property
    def angles(self) -> list[float]: ...
    @property
    def angular_increment(self) -> float: ...

class NativeAgent(Entity):
    angular_speed: float
    behavior: navground.core._navground.Behavior
    color: str
    control_period: float
    enabled: bool
    id: int
    kinematics: navground.core._navground.Kinematics
    last_cmd: navground.core._navground.Twist2
    orientation: float
    pose: navground.core._navground.Pose2
    position: Vector2
    radius: float
    state_estimation: StateEstimation
    tags: set[str]
    task: Task
    twist: navground.core._navground.Twist2
    type: str
    velocity: Vector2
    def __init__(self, *args, **kwargs) -> None: ...
    def actuate(self, cmd: navground.core._navground.Twist2, time_step: float) -> None: ...
    def add_tag(self, tag: str) -> None: ...
    def get_last_cmd(self, frame: navground.core._navground.Frame) -> navground.core._navground.Twist2: ...
    def has_been_stuck_since(self, time: float) -> bool: ...
    def remove_tag(self, tag: str) -> None: ...
    @property
    def actuated_cmd(self) -> navground.core._navground.Twist2: ...
    @property
    def controller(self) -> navground.core._navground.Controller: ...
    @property
    def idle(self) -> bool: ...
    @property
    def time_since_stuck(self) -> float: ...

class NativeWorld:
    bounding_box: BoundingBox
    collisions: set[tuple[Entity, Entity]]
    seed: int
    step: int
    time: float
    def __init__(self) -> None: ...
    def _prepare(self) -> None: ...
    def actuate(self, time_step: float) -> None: ...
    def add_agent(self, agent: Agent) -> None: ...
    def add_callback(self, callback: Callable[[], None]) -> None: ...
    @overload
    def add_obstacle(self, disc: navground.core._navground.Disc) -> None: ...
    @overload
    def add_obstacle(self, obstacle: Obstacle) -> None: ...
    def add_random_obstacles(self, number: int, min_radius: float, max_radius: float, margin: float = ..., max_tries: int = ...) -> None: ...
    @overload
    def add_wall(self, line: navground.core._navground.LineSegment) -> None: ...
    @overload
    def add_wall(self, wall: Wall) -> None: ...
    def agents_are_idle(self) -> bool: ...
    def agents_are_idle_or_stuck(self) -> bool: ...
    def clear_collisions(self) -> None: ...
    def compute_safety_violation(self, agent: Agent, safety_margin: float | None = ...) -> float: ...
    def copy_random_generator(self, world: World) -> None: ...
    def get_agents_in_collision(self, duration: float = ...) -> list[Agent]: ...
    def get_agents_in_deadlock(self, duration: float = ...) -> list[Agent]: ...
    def get_agents_in_region(self, bounding_box: BoundingBox) -> list[Agent]: ...
    def get_discs_in_region(self, bounding_box: BoundingBox, ignore_lattice: bool = ...) -> list[navground.core._navground.Disc]: ...
    def get_entity(self, uid: int) -> Entity: ...
    def get_lattice(self, axis: int) -> tuple[float, float] | None: ...
    def get_lattice_grid(self, include_zero: bool = ..., c8: bool = ...) -> list[Vector2]: ...
    def get_line_obstacles_in_region(self, bounding_box: BoundingBox) -> list[navground.core._navground.LineSegment]: ...
    def get_neighbors(self, agent: Agent, distance: float, ignore_lattice: bool = ...) -> list[navground.core._navground.Neighbor]: ...
    def get_obstacles_in_region(self, bounding_box: BoundingBox) -> list[Obstacle]: ...
    def in_collision(self, e1: Entity, e2: Entity) -> bool: ...
    def index_of_agent(self, agent: Agent) -> int | None: ...
    def record_collision(self, e1: Entity, e2: Entity) -> None: ...
    def reset_callbacks(self) -> None: ...
    def run(self, steps: int, time_step: float) -> None: ...
    def run_until(self, condition: Callable[[], bool], time_step: float) -> None: ...
    def set_lattice(self, axis: int, value: tuple[float, float] | None) -> None: ...
    def set_termination_condition(self, condition: Callable[[World], bool] | None) -> None: ...
    def should_terminate(self) -> bool: ...
    def snap_twists_to_zero(self, epsilon: float = ...) -> None: ...
    def space_agents_apart(self, minimal_distance: float = ..., with_safety_margin: bool = ..., max_iterations: int = ...) -> None: ...
    def subdivide_bounding_box(self, arg0: BoundingBox, arg1: bool) -> list[tuple[Vector2, BoundingBox]]: ...
    def update(self, time_step: float) -> None: ...
    def update_dry(self, time_step: float, advance_time: bool = ...) -> None: ...
    @property
    def agents(self) -> list[Agent]: ...
    @property
    def discs(self) -> list[navground.core._navground.Disc]: ...
    @property
    def has_termination_condition(self) -> bool: ...
    @property
    def line_obstacles(self) -> list[navground.core._navground.LineSegment]: ...
    @property
    def minimal_bounding_box(self) -> BoundingBox: ...
    @property
    def obstacles(self) -> list[Obstacle]: ...
    @property
    def walls(self) -> list[Wall]: ...

class Obstacle(Entity):
    disc: navground.core._navground.Disc
    @overload
    def __init__(self, position: Vector2, radius: float) -> None: ...
    @overload
    def __init__(self, disc: navground.core._navground.Disc) -> None: ...

class OdometryStateEstimation(Sensor):
    angular_speed_error: float
    longitudinal_speed_error: float
    transversal_speed_error: float
    def __init__(self, longitudinal_speed_error: float = ..., transversal_speed_error: float = ..., angular_speed_error: float = ..., name: str = ...) -> None: ...
    @property
    def pose(self) -> navground.core._navground.Pose2: ...

class Probe:
    def __init__(self) -> None: ...
    def _finalize(self, arg0: ExperimentalRun) -> None: ...
    def _prepare(self, arg0: ExperimentalRun) -> None: ...
    def _update(self, arg0: ExperimentalRun) -> None: ...

class RecordConfig:
    actuated_cmd: bool
    cmd: bool
    collisions: bool
    deadlocks: bool
    efficacy: bool
    neighbors: RecordNeighborsConfig
    pose: bool
    safety_violation: bool
    sensing: list[RecordSensingConfig]
    target: bool
    task_events: bool
    time: bool
    twist: bool
    use_agent_uid_as_key: bool
    world: bool
    def __init__(self, time: bool = ..., pose: bool = ..., twist: bool = ..., cmd: bool = ..., actuated_cmd: bool = ..., target: bool = ..., safety_violation: bool = ..., collisions: bool = ..., task_events: bool = ..., deadlocks: bool = ..., efficacy: bool = ..., world: bool = ..., neighbors: RecordNeighborsConfig = ..., use_agent_uid_as_key: bool = ..., sensing: list[RecordSensingConfig] = ...) -> None: ...
    @staticmethod
    def all(value: bool) -> RecordConfig: ...
    def record_sensor(self, name: str, sensor: Sensor, agent_indices: list[int]) -> None: ...
    def set_all(self, value: bool) -> None: ...

class RecordNeighborsConfig:
    enabled: bool
    number: int
    relative: bool
    def __init__(self, enabled: bool = ..., number: int = ..., relative: bool = ...) -> None: ...

class RecordProbe(Probe):
    def __init__(self, record: Dataset = ...) -> None: ...
    @property
    def data(self) -> Dataset: ...

class RecordSensingConfig:
    agent_indices: list[int]
    name: str
    sensor: Sensor
    def __init__(self, name: str = ..., sensor: StateEstimation = ..., agent_indices: list[int] = ...) -> None: ...

class Scenario(ScenarioRegister, navground.core._navground.HasProperties):
    class Group:
        def __init__(self) -> None: ...
    obstacles: list[navground.core._navground.Disc]
    walls: list[navground.core._navground.LineSegment]
    def __init__(self) -> None: ...
    def add_init(self, initializer: Callable[[World], None]) -> None: ...
    def init_world(self, world: World, seed: int | None = ...) -> None: ...
    def set_yaml(self, arg0: str) -> None: ...

class ScenarioRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, navground.core._navground.Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Scenario | None: ...

class SensingProbe(Probe):
    def __init__(self, name: str = ..., sensor: Sensor = ..., agent_indices: list[int] = ...) -> None: ...
    def get_data(self) -> dict[int, dict[str, Dataset]]: ...

class Sensor(StateEstimation):
    def __init__(self, name: str = ...) -> None: ...
    def prepare(self, arg0: navground.core._navground.SensingState) -> None: ...
    @property
    def description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class SensorCombination(Sensor):
    sensors: list[Sensor]
    def __init__(self, sensors: list[Sensor] = ...) -> None: ...

class SimpleScenario(Scenario):
    def __init__(self) -> None: ...

class StateEstimation(StateEstimationRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def update(self, agent: Agent, world: World, state: navground.core._navground.EnvironmentState) -> None: ...
    @property
    def type(self) -> str: ...

class StateEstimationRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, navground.core._navground.Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> StateEstimation | None: ...

class Task(TaskRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def add_callback(self, callback: Callable[[list[float]], None]) -> None: ...
    def done(self) -> bool: ...
    @property
    def log_size(self) -> int: ...
    @property
    def type(self) -> str: ...

class TaskRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, navground.core._navground.Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Task | None: ...

class Wall(Entity):
    line: navground.core._navground.LineSegment
    @overload
    def __init__(self, p1: Vector2, p2: Vector2) -> None: ...
    @overload
    def __init__(self, line: navground.core._navground.LineSegment) -> None: ...

class WaypointsTask(Task):
    loop: float
    tolerance: float
    waypoints: list[Vector2]
    def __init__(self, waypoints: list[Vector2] = ..., loop: bool = ..., tolerance: float = ...) -> None: ...
    @property
    def log_size(self) -> int: ...

class World(NativeWorld):
    random_generator: numpy.random.Generator
    seed: int
    def __init__(self) -> None: ...
    def add_agent(self, agent: Agent) -> None: ...
    def copy_random_generator(self, world: World) -> None: ...

@overload
def dump(task: Task) -> str: ...
@overload
def dump(state_estimation: StateEstimation) -> str: ...
@overload
def dump(world: World) -> str: ...
@overload
def dump(scenario: Scenario) -> str: ...
@overload
def dump(agent: Agent) -> str: ...
@overload
def dump(experiment: Experiment) -> str: ...
@overload
def dump(behavior: navground.core._navground.Behavior) -> str: ...
@overload
def dump(kinematics: navground.core._navground.Kinematics) -> str: ...
@overload
def dump(modulation: navground.core._navground.BehaviorModulation) -> str: ...
def load_agent(value: str) -> Agent | None: ...
def load_experiment(value: str) -> Experiment | None: ...
def load_scenario(value: str) -> Scenario | None: ...
def load_state_estimation(value: str) -> StateEstimation | None: ...
def load_task(value: str) -> Task | None: ...
def load_world(value: str) -> World | None: ...
def use_compact_samplers(value: bool) -> None: ...
def uses_doubles() -> bool: ...
