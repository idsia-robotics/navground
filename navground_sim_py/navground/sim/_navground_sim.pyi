import abc
import datetime
import navground.core._navground
import numpy
import pathlib
from collections.abc import Sequence, Callable
from typing import Any, ClassVar, overload
from navground.core._navground import Vector2, Vector2Like
import tqdm

class Agent(NativeAgent):
    behavior: navground.core._navground.Behavior | None
    kinematics: navground.core._navground.Kinematics | None
    state_estimation: StateEstimation | None
    state_estimations: list[StateEstimation]
    task: Task | None
    def __init__(self, radius: float = ..., behavior: navground.core._navground.Behavior | None = ..., kinematics: navground.core._navground.Kinematics | None = ..., task: Task | None = ..., state_estimations: list[StateEstimation] = ..., control_period: float = ..., id: int = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Agent | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class AntipodalScenario(Scenario):
    orientation_noise: float
    position_noise: float
    radius: float
    shuffle: bool
    tolerance: float
    def __init__(self, radius: float = ..., tolerance: float = ..., position_noise: float = ..., orientation_noise: float = ..., shuffle: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class BoundarySensor(Sensor):
    max_x: float
    max_y: float
    min_x: float
    min_y: float
    range: float
    def __init__(self, range: float = ..., min_x: float = ..., max_x: float = ..., min_y: float = ..., max_y: float = ..., name: str = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class BoundedStateEstimation(StateEstimation):
    range: float
    update_static_obstacles: bool
    def __init__(self, range: float = ..., update_static_obstacles: bool = ...) -> None: ...
    def _neighbors_of_agent(self, agent: NativeAgent, world: NativeWorld) -> list[navground.core._navground.Neighbor]: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class BoundingBox:
    @overload
    def __init__(self, min_x: float, max_x: float, min_y: float, max_y: float) -> None: ...
    @overload
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    def contains(self, point: Vector2Like) -> bool: ...
    def covers(self, other: BoundingBox) -> bool: ...
    def distance(self, other: BoundingBox) -> float: ...
    def expand_by(self, delta: Vector2Like) -> None: ...
    def expand_to_include(self, other: BoundingBox) -> None: ...
    def intersection(self, other: BoundingBox) -> BoundingBox | None: ...
    def intersects(self, other: BoundingBox) -> bool: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def translate(self, delta: Vector2Like) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def height(self) -> float: ...
    @property
    def max_x(self) -> float: ...
    @property
    def max_y(self) -> float: ...
    @property
    def min_x(self) -> float: ...
    @property
    def min_y(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...
    @property
    def width(self) -> float: ...

class CorridorScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    length: float
    width: float
    bidirectional: bool
    def __init__(self, width: float = ..., length: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ..., bidirectional: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class CrossScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    target_margin: float
    tolerance: float
    def __init__(self, side: float = ..., tolerance: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ..., target_margin: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class CrossTorusScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    def __init__(self, side: float = ..., agent_margin: float = ..., add_safety_to_agent_margin: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class Dataset:
    dtype: numpy.dtype[Any]
    item_shape: list[int]
    def __init__(self, data: numpy.typing.ArrayLike | None = ..., dtype: numpy.typing.DTypeLike | None = ..., item_shape: list[int] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def append(self, values: numpy.typing.ArrayLike, reset: bool = ...) -> None: ...
    def push(self, value: float) -> None: ...
    def reset(self) -> None: ...
    def write_buffer(self, buffer: navground.core._navground.Buffer, index: int) -> bool: ...
    def get_buffer(self, index: int) -> navground.core._navground.Buffer: ...
    # Don't know how to type annotate it
    def __buffer__(self, *args, **kwargs): ...  # type: ignore
    def __iter__(self) -> numpy.typing.NDArray[Any]: ...
    def __len__(self) -> int: ...
    # Don't know how to type annotate it
    def __release_buffer__(self, *args, **kwargs): ...  # type: ignore
    @property
    def is_valid(self) -> bool: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def size(self) -> int: ...
    @property
    def number_of_items(self) -> int: ...

class DirectionTask(Task):
    direction: Vector2
    def __init__(self, direction: Vector2Like = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class DiscsStateEstimation(Sensor):
    include_valid: bool
    max_id: int
    max_radius: float
    max_speed: float
    number: int
    range: float
    use_nearest_point: bool
    def __init__(self, range: float = ..., number: int = ..., max_radius: float = ..., max_speed: float = ..., include_valid: bool = ..., use_nearest_point: bool = ..., max_id: int = ..., name: str = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class Entity:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def has_been_in_collision_since(self, time: float) -> bool: ...
    @property
    def _uid(self) -> int: ...
    @property
    def last_collision_time(self) -> float: ...

ScenarioInitCallback = Callable[[Scenario, int], None]

class Experiment:
    def run_mp(experiment: Experiment,
               number_of_processes: int,
               keep: bool = ...,
               number_of_runs: int | None = ...,
               start_index: int | None = ...,
               callback: Callable[[int], None] | None = ...,
               bar: tqdm.tqdm[Any] | None = ...,
               scenario_init_callback: ScenarioInitCallback | None = ...,
               use_multiprocess: bool = ...,
               load_plugins: bool = True) -> None:  ...
    def setup_tqdm(self, bar: tqdm.tqdm[Any], number_of_runs: int | None = ...) -> None: ...
    _group_record_probes: dict[str, Callable[[], GroupRecordProbe]]
    _probes: list[Callable[[], Probe]]
    _record_probes: dict[str, Callable[[], RecordProbe]]
    name: str
    number_of_runs: int
    record_config: RecordConfig
    run_callbacks: dict[bool, list[Callable[[ExperimentalRun], None]]]
    run_index: int
    save_directory: pathlib.Path
    scenario: Scenario
    scenario_init_callback: Callable[[Scenario, int], None] | None
    steps: int
    terminate_when_all_idle_or_stuck: bool
    time_step: float
    def __init__(self, time_step: float = ..., steps: int = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_group_record_probe(self, key: str, probe: Callable[[], GroupRecordProbe]) -> None: ...
    def add_probe(self, factory: Callable[[], Probe]) -> None: ...
    def add_record_probe(self, key: str, probe: Callable[[Dataset], RecordProbe]) -> None: ...
    def add_run(self, seed: int, run: ExperimentalRun) -> None: ...
    def add_run_callback(self, callback: Callable[[ExperimentalRun], None], at_init: bool = ...) -> None: ...
    def clear_run_callbacks(self) -> None: ...
    def dump(self) -> str: ...
    def get_run(self, index: int) -> ExperimentalRun: ...
    def init_run(self, seed: int, world: NativeWorld = ...) -> ExperimentalRun: ...
    @staticmethod
    def load(value: str) -> Experiment | None: ...
    def remove_all_runs(self) -> None: ...
    def remove_run(self, seed: int) -> None: ...
    def run(self, keep: bool = ..., number_of_threads: int = ..., start_index: int | None = ..., number_of_runs: int | None = ..., data_path: pathlib.Path | None = ...) -> None: ...
    def run_once(self, seed: int) -> ExperimentalRun: ...
    def save(self, directory: pathlib.Path | None = ..., path: pathlib.Path | None = ...) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def start(self, path: pathlib.Path | None = ...) -> None: ...
    def start_run(self, run: ExperimentalRun) -> None: ...
    def stop(self, save_runs: bool = ...) -> None: ...
    def stop_run(self, run: ExperimentalRun) -> None: ...
    def update_run(self, run: ExperimentalRun) -> None: ...
    @property
    def begin_time(self) -> datetime.datetime: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def is_running(self) -> bool: ...
    @property
    def path(self) -> pathlib.Path | None: ...
    @property
    def runs(self) -> dict[int, ExperimentalRun]: ...

class ExperimentalRun:
    def __init__(self, world: NativeWorld, time_step: float = ..., steps: int = ..., terminate_when_all_idle_or_stuck: bool = ..., record_config: RecordConfig = ..., seed: int = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_group_record_probe(self, key: str, probe: Callable[[], GroupRecordProbe]) -> GroupRecordProbe: ...
    def add_probe(self, probe: Probe) -> None: ...
    def add_record(self, key: str, data: numpy.typing.ArrayLike | None = ..., dtype: numpy.typing.DTypeLike | None = ..., item_shape: list[int] = ...) -> Dataset: ...
    def add_record_probe(self, key: str, probe: Callable[[Dataset], RecordProbe]) -> RecordProbe: ...
    @staticmethod
    def data_from_target(target: navground.core._navground.Target) -> list[float]: ...
    def get_collision_events(self, min_interval: int = ...) -> Dataset: ...
    def get_collisions_at_step(self, step: int) -> set[tuple[Entity, Entity]]: ...
    def get_record(self, key: str = ...) -> Dataset: ...
    def get_record_names(self, group: str = ...) -> set[str]: ...
    def get_records(self, group: str = ...) -> dict[str, Dataset]: ...
    def get_sensing_for(self, id: int) -> dict[str, Dataset]: ...
    def get_steps_to_collision(self, min_interval: int = ...) -> Dataset: ...
    def get_task_events(self, agent: NativeAgent) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    def go_to_step(self, step: int, ignore_collisions: bool = ..., ignore_twists: bool = ..., ignore_cmds: bool = ..., ignore_targets: bool = ..., ignore_sensing: bool = ...) -> bool: ...
    def index_of_agent(self, agent: NativeAgent) -> int | None: ...
    def reset(self) -> None: ...
    def run(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    @staticmethod
    def target_from_data(data: list[float]) -> navground.core._navground.Target: ...
    def update(self) -> None: ...
    @property
    def actuated_commands(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def bounding_box(self) -> BoundingBox: ...
    @property
    def collisions(self) -> numpy.typing.NDArray[numpy.int_]: ...
    @property
    def commands(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def deadlocks(self) -> numpy.typing.NDArray[numpy.int_]: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def efficacy(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def final_sim_time(self) -> float: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def maximal_steps(self) -> int: ...
    @property
    def neighbors(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def poses(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def record_config(self) -> RecordConfig: ...
    @property
    def record_names(self) -> set[str]: ...
    @property
    def recorded_steps(self) -> int: ...
    @property
    def records(self) -> dict[str, Dataset]: ...
    @property
    def safety_violations(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def seed(self) -> int: ...
    @property
    def sensing(self) -> dict[int, dict[str, Dataset]]: ...
    @property
    def targets(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def task_events(self) -> dict[int, numpy.typing.NDArray[numpy.floating[Any]]]: ...
    @property
    def terminate_when_all_idle_or_stuck(self) -> bool: ...
    @property
    def time_step(self) -> float: ...
    @property
    def times(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def twists(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def world(self) -> World: ...

class GoToPoseTask(WaypointsTask):
    point: Vector2
    orientation: float
    def __init__(self, points: Vector2Like = ..., orientation: float = ..., tolerance: float = ..., angular_tolerance: float = ...) -> None: ...

class GroupRecordProbe(Probe):
    def __init__(self, factory: Callable[[str], Dataset] | None = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_data(self, key: str) -> Dataset: ...
    def get_shapes(self, world: World, use_agent_uid_as_key: bool) -> dict[str, list[int]]: ...

class LidarScan:
    fov: float
    max_range: float
    start_angle: float
    @property
    def angles(self) -> list[float]: ...
    @property
    def angular_increment(self) -> float: ...
    @property
    def ranges(self) -> list[float]: ...

class LidarStateEstimation(Sensor):
    error_bias: float
    error_std_dev: float
    field_of_view: float
    position: Vector2
    range: float
    resolution: int
    start_angle: float
    def __init__(self, range: float = ..., start_angle: float = ..., field_of_view: float = ..., resolution: int = ..., position: Vector2Like = ..., error_bias: float = ..., error_std_dev: float = ..., name: str = ...) -> None: ...
    def read_ranges(self, state: navground.core._navground.SensingState) -> list[float]: ...
    @staticmethod
    def read_ranges_with_name(state: navground.core._navground.SensingState, name: str) -> list[float]: ...
    def read_scan(self, state: navground.core._navground.SensingState) -> LidarScan | None: ...
    @staticmethod
    def read_scan_with_name(state: navground.core._navground.SensingState, name: str) -> LidarScan | None: ...
    @property
    def angles(self) -> list[float]: ...
    @property
    def angular_increment(self) -> float: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class LocalGridMapStateEstimation(Sensor):
    class FootprintType:
        __members__: ClassVar[dict[str, LocalGridMapStateEstimation.FootprintType]] = ...  # read-only
        __entries: ClassVar[dict[str, tuple[LocalGridMapStateEstimation.FootprintType, str]]] = ...
        rectangular: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
        circular: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
        none: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    external_lidars: list[str]
    external_odometry: str
    height: int
    include_transformation: bool
    lidars: list[LidarStateEstimation]
    odometry: OdometryStateEstimation
    resolution: float
    width: int
    footprint: LocalGridMapStateEstimation.FootprintType
    def __init__(self, lidars: list[LidarStateEstimation] = ..., external_lidars: list[str] = ..., odometry: OdometryStateEstimation = ..., external_odometry: str = ..., width: int = ..., height: int = ..., resolution: float = ..., include_transformation: bool = ..., footprint: LocalGridMapStateEstimation.FootprintType = ..., name: str = ...) -> None: ...
    def read_gridmap(self, state: navground.core._navground.SensingState) -> navground.core._navground.GridMap | None: ...
    @staticmethod
    def read_gridmap_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.GridMap | None: ...
    def read_transform(self, state: navground.core._navground.SensingState) -> navground.core._navground.Pose2 | None: ...
    @staticmethod
    def read_transform_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.Pose2 | None: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class NativeAgent(Entity):
    angular_speed: float
    behavior: navground.core._navground.Behavior | None
    color: str
    control_period: float
    enabled: bool
    id: int
    kinematics: navground.core._navground.Kinematics | None
    last_cmd: navground.core._navground.Twist2
    orientation: float
    pose: navground.core._navground.Pose2
    position: Vector2
    radius: float
    state_estimation: StateEstimation | None
    state_estimations: list[StateEstimation]
    tags: set[str]
    task: Task | None
    twist: navground.core._navground.Twist2
    type: str
    velocity: Vector2
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def actuate(self, cmd: navground.core._navground.Twist2, time_step: float) -> None: ...
    def add_tag(self, tag: str) -> None: ...
    def get_last_cmd(self, frame: navground.core._navground.Frame) -> navground.core._navground.Twist2: ...
    def has_been_stuck_since(self, time: float) -> bool: ...
    def remove_tag(self, tag: str) -> None: ...
    @property
    def actuated_cmd(self) -> navground.core._navground.Twist2: ...
    @property
    def controller(self) -> navground.core._navground.Controller: ...
    @property
    def idle(self) -> bool: ...
    @property
    def time_since_stuck(self) -> float: ...

class NativeWorld:
    bounding_box: BoundingBox
    collisions: set[tuple[Entity, Entity]]
    seed: int
    step: int
    time: float
    def __init__(self) -> None: ...
    def _prepare(self) -> None: ...
    def _close(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def actuate(self, time_step: float) -> None: ...
    def add_agent(self, agent: Agent) -> None: ...
    def add_callback(self, callback: Callable[[], None]) -> None: ...
    @overload
    def add_obstacle(self, disc: navground.core._navground.Disc) -> None: ...
    @overload
    def add_obstacle(self, obstacle: Obstacle) -> None: ...
    def add_random_obstacles(self, number: int, min_radius: float, max_radius: float, margin: float = ..., max_tries: int = ...) -> None: ...
    @overload
    def add_wall(self, line: navground.core._navground.LineSegment) -> None: ...
    @overload
    def add_wall(self, wall: Wall) -> None: ...
    def agents_are_idle(self) -> bool: ...
    def agents_are_idle_or_stuck(self) -> bool: ...
    def clear_collisions(self) -> None: ...
    def compute_safety_violation(self, agent: NativeAgent, safety_margin: float | None = ...) -> float: ...
    # def copy_random_generator(self, world: NativeWorld) -> None: ...
    def dump(self) -> str: ...
    def get_agents_in_collision(self, duration: float = ...) -> list[Agent]: ...
    def get_agents_in_deadlock(self, duration: float = ...) -> list[Agent]: ...
    def get_agents_in_region(self, bounding_box: BoundingBox) -> list[Agent]: ...
    def get_discs_in_region(self, bounding_box: BoundingBox, ignore_lattice: bool = ...) -> list[navground.core._navground.Disc]: ...
    def get_entity(self, uid: int) -> Entity: ...
    def get_lattice(self, axis: int) -> tuple[float, float] | None: ...
    def get_lattice_grid(self, include_zero: bool = ..., c8: bool = ...) -> list[Vector2]: ...
    def get_line_obstacles_in_region(self, bounding_box: BoundingBox) -> list[navground.core._navground.LineSegment]: ...
    def get_neighbors(self, agent: NativeAgent, distance: float, ignore_lattice: bool = ...) -> list[navground.core._navground.Neighbor]: ...
    def get_obstacles_in_region(self, bounding_box: BoundingBox) -> list[Obstacle]: ...
    def in_collision(self, e1: Entity, e2: Entity) -> bool: ...
    def index_of_agent(self, agent: NativeAgent) -> int | None: ...
    @staticmethod
    def load(value: str) -> World | None: ...
    def record_collision(self, e1: Entity, e2: Entity) -> None: ...
    def reset_callbacks(self) -> None: ...
    def run(self, steps: int, time_step: float) -> None: ...
    def run_until(self, condition: Callable[[], bool], time_step: float) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def set_lattice(self, axis: int, value: tuple[float, float] | None) -> None: ...
    def set_termination_condition(self, condition: Callable[[World], bool] | None) -> None: ...
    def should_terminate(self) -> bool: ...
    def snap_twists_to_zero(self, epsilon: float = ...) -> None: ...
    def space_agents_apart(self, minimal_distance: float = ..., with_safety_margin: bool = ..., max_iterations: int = ...) -> None: ...
    def subdivide_bounding_box(self, bounding_box: BoundingBox, ignore_lattice: bool = ...) -> list[tuple[Vector2, BoundingBox]]: ...
    def update(self, time_step: float) -> None: ...
    def update_dry(self, time_step: float, advance_time: bool = ...) -> None: ...
    @property
    def agents(self) -> list[Agent]: ...
    @property
    def discs(self) -> list[navground.core._navground.Disc]: ...
    @property
    def has_termination_condition(self) -> bool: ...
    @property
    def line_obstacles(self) -> list[navground.core._navground.LineSegment]: ...
    @property
    def minimal_bounding_box(self) -> BoundingBox: ...
    @property
    def obstacles(self) -> list[Obstacle]: ...
    @property
    def walls(self) -> list[Wall]: ...

class Obstacle(Entity):
    disc: navground.core._navground.Disc
    @overload
    def __init__(self, position: Vector2Like, radius: float) -> None: ...
    @overload
    def __init__(self, disc: navground.core._navground.Disc) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Obstacle | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class OdometryStateEstimation(Sensor):
    angular_speed_bias: float
    angular_speed_std_dev: float
    longitudinal_speed_bias: float
    longitudinal_speed_std_dev: float
    transversal_speed_bias: float
    transversal_speed_std_dev: float
    update_ego_state: bool
    update_sensing_state: bool
    def __init__(self, longitudinal_speed_bias: float = ..., longitudinal_speed_std_dev: float = ..., transversal_speed_bias: float = ..., transversal_speed_std_dev: float = ..., angular_speed_bias: float = ..., angular_speed_std_dev: float = ..., update_sensing_state: bool = ..., update_ego_state: bool = ..., name: str = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def pose(self) -> navground.core._navground.Pose2: ...
    @property
    def twist(self) -> navground.core._navground.Twist2: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...
    def read_pose(self, state: navground.core._navground.SensingState) -> navground.core._navground.Pose2 | None: ...
    @staticmethod
    def read_pose_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.Pose2 | None: ...

class Probe:
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def finalize(self, run: ExperimentalRun) -> None: ...
    def prepare(self, run: ExperimentalRun) -> None: ...
    def update(self, run: ExperimentalRun) -> None: ...

class RunConfig:
    time_step: float
    steps: int
    terminate_when_all_idle_or_stuck: bool
    def __init__(self, time_step: float = ..., steps: int = ..., terminate_when_all_idle_or_stuck: bool = ...) -> None: ...

class RecordConfig:
    actuated_cmd: bool
    cmd: bool
    collisions: bool
    deadlocks: bool
    efficacy: bool
    neighbors: RecordNeighborsConfig
    pose: bool
    safety_violation: bool
    sensing: list[RecordSensingConfig]
    target: bool
    task_events: bool
    time: bool
    twist: bool
    use_agent_uid_as_key: bool
    world: bool
    def __init__(self, time: bool = ..., pose: bool = ..., twist: bool = ..., cmd: bool = ..., actuated_cmd: bool = ..., target: bool = ..., safety_violation: bool = ..., collisions: bool = ..., task_events: bool = ..., deadlocks: bool = ..., efficacy: bool = ..., world: bool = ..., neighbors: RecordNeighborsConfig = ..., use_agent_uid_as_key: bool = ..., sensing: list[RecordSensingConfig] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def all(value: bool) -> RecordConfig: ...
    def record_sensor(self, name: str, sensor: Sensor, agent_indices: list[int]) -> None: ...
    def set_all(self, value: bool) -> None: ...

class RecordNeighborsConfig:
    enabled: bool
    number: int
    relative: bool
    def __init__(self, enabled: bool = ..., number: int = ..., relative: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class RecordProbe(Probe):
    def __init__(self, record: Dataset = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_shape(self, world: World) -> list[int]: ...
    @property
    def data(self) -> Dataset: ...

class RecordSensingConfig:
    agent_indices: list[int]
    name: str
    sensor: Sensor
    def __init__(self, name: str = ..., sensor: StateEstimation = ..., agent_indices: list[int] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class Scenario(ScenarioRegister, navground.core._navground.HasProperties):
    class Group(abc.ABC):
        def __init__(self) -> None: ...
        def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
        @abc.abstractmethod
        def add_to_world(self, world: World, seed: int | None = ...) -> None: ...

    bounding_box: BoundingBox | None
    groups: list[Scenario.Group]
    obstacles: list[navground.core._navground.Disc]
    walls: list[navground.core._navground.LineSegment]
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_init(self, initializer: Callable[[World, int | None], None]) -> str: ...
    def set_init(self, key: str, initializer: Callable[[World, int | None], None]) -> None: ...
    def remove_init(self, key: str) -> None: ...
    def clear_inits(self) -> None: ...
    def init_world(self, world: World, seed: int | None = ...) -> None: ...
    @property
    def inits(self) -> dict[str, Callable[[World, int | None], None]]: ...
    @staticmethod
    def load(value: str) -> Scenario | None: ...
    def make_world(self, seed: int | None = ...) -> World: ...
    def set_yaml(self, value: str) -> None: ...

class ScenarioRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Scenario | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    def dump(self) -> str: ...

class SensingProbe(Probe):
    def __init__(self, name: str = ..., sensor: Sensor = ..., agent_indices: list[int] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_data(self) -> dict[int, dict[str, Dataset]]: ...

class Sensor(abc.ABC, StateEstimation):
    name: str
    def __init__(self, name: str = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @abc.abstractmethod
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...
    def prepare_state(self, state: navground.core._navground.SensingState) -> None: ...
    @property
    def description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class SensorCombination(Sensor):
    sensors: list[Sensor]
    def __init__(self, sensors: list[Sensor] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

class SimpleScenario(Scenario):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class StateEstimation(StateEstimationRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def load(value: str) -> StateEstimation | None: ...
    def prepare(self, agent: Agent, world: World) -> None: ...
    def update(self, agent: Agent, world: World, state: navground.core._navground.EnvironmentState) -> None: ...
    def close(self) -> None: ...

class StateEstimationRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> StateEstimation | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    def dump(self) -> str: ...

class Task(TaskRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_callback(self, callback: Callable[[list[float]], None]) -> None: ...
    def done(self) -> bool: ...
    def get_log_size(self) -> int: ...
    @staticmethod
    def load(value: str) -> Task | None: ...
    def log_event(self, log: list[float]) -> None: ...
    def prepare(self, agent: Agent, world: World) -> None: ...
    def update(self, agent: Agent, world: World, time: float) -> None: ...
    def close(self) -> None: ...
    @property
    def log_size(self) -> int: ...

class TaskRegister:
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Task | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    def dump(self) -> str: ...

class Wall(Entity):
    line: navground.core._navground.LineSegment
    @overload
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    @overload
    def __init__(self, line: navground.core._navground.LineSegment) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Wall | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class WaypointsTask(Task):
    loop: bool
    random: bool
    tolerance: float
    angular_tolerance: float
    tolerances: list[float]
    angular_tolerances: list[float]
    waypoints: list[Vector2]
    orientations: list[float]
    def __init__(self, waypoints: Sequence[Vector2Like] = ..., loop: bool = ..., tolerance: float = ..., random: bool = ..., tolerances: list[float] = ..., orientations: list[float] = ..., angular_tolerance: float = ..., angular_tolerances: list[float] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_effective_tolerance(self, index: int) -> float: ...
    def get_effective_angular_tolerance(self, index: int) -> float: ...

class World(NativeWorld):
    random_generator: numpy.random.Generator
    seed: int
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_agent(self, agent: Agent) -> None: ...
    def copy_random_generator(self, world: World) -> None: ...

def bundle_schema() -> dict[str, Any]: ...
def use_compact_samplers(value: bool) -> None: ...
def uses_doubles() -> bool: ...
def get_build_info() -> navground.core._navground.BuildInfo: ...
def get_build_dependencies() -> dict[str, navground.core._navground.DependencyInfo]: ...
