import collections.abc
import datetime
import enum
import navground.core._navground
import numpy
import numpy.typing
import os
import pathlib
import typing
from typing import Any, Callable, ClassVar, overload
import tqdm
from navground.core._navground import Vector2, Vector2Like

class Agent(NativeAgent):
    behavior: navground.core._navground.Behavior | None
    kinematics: navground.core._navground.Kinematics | None
    state_estimation: StateEstimation | None
    state_estimations: list[StateEstimation]
    task: Task | None
    def __init__(self, radius: typing.SupportsFloat = ..., behavior: navground.core._navground.Behavior | None = ..., kinematics: navground.core._navground.Kinematics | None = ..., task: Task | None = ..., state_estimations: collections.abc.Sequence[StateEstimation] = ..., control_period: typing.SupportsFloat = ..., id: typing.SupportsInt = ...) -> None: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Agent | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class AgentSampler(Scenario.Group):
    once: bool
    def add_to_world(self, world: World, seed: typing.SupportsInt | None = ...) -> None: ...
    def count(self) -> int: ...
    def done(self) -> bool: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> AgentSampler | None: ...
    def reset(self, index: typing.SupportsInt | None = ..., keep: bool = ...) -> None: ...
    def sample(self, world: World) -> Agent: ...

class AntipodalScenario(Scenario):
    orientation_noise: float
    position_noise: float
    radius: float
    shuffle: bool
    tolerance: float
    def __init__(self, radius: typing.SupportsFloat = ..., tolerance: typing.SupportsFloat = ..., position_noise: typing.SupportsFloat = ..., orientation_noise: typing.SupportsFloat = ..., shuffle: bool = ...) -> None: ...

class BoundarySensor(Sensor):
    max_x: float
    max_y: float
    min_x: float
    min_y: float
    range: float
    def __init__(self, range: typing.SupportsFloat = ..., min_x: typing.SupportsFloat = ..., max_x: typing.SupportsFloat = ..., min_y: typing.SupportsFloat = ..., max_y: typing.SupportsFloat = ..., name: str = ...) -> None: ...

class BoundedStateEstimation(StateEstimation):
    range: float
    update_static_obstacles: bool
    def __init__(self, range: typing.SupportsFloat = ..., update_static_obstacles: bool = ...) -> None: ...
    def _neighbors_of_agent(self, agent: Agent, world: World) -> list[navground.core._navground.Neighbor]: ...

class BoundingBox:
    @overload
    def __init__(self, min_x: typing.SupportsFloat, max_x: typing.SupportsFloat, min_y: typing.SupportsFloat, max_y: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    def contains(self, point: Vector2Like) -> bool: ...
    def covers(self, other: BoundingBox) -> bool: ...
    def distance(self, other: BoundingBox) -> float: ...
    @staticmethod
    def envelop(position: Vector2Like, radius: typing.SupportsFloat) -> BoundingBox: ...
    def expand_by(self, delta: Vector2Like) -> None: ...
    def expand_to_include(self, other: BoundingBox) -> None: ...
    @staticmethod
    def from_tuple(value: tuple[float, float, float, float]) -> BoundingBox: ...
    def intersection(self, other: BoundingBox) -> BoundingBox | None: ...
    def intersects(self, other: BoundingBox) -> bool: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def set_max_x(self, value: typing.SupportsFloat) -> BoundingBox: ...
    def set_max_y(self, value: typing.SupportsFloat) -> BoundingBox: ...
    def set_min_x(self, value: typing.SupportsFloat) -> BoundingBox: ...
    def set_min_y(self, value: typing.SupportsFloat) -> BoundingBox: ...
    def to_tuple(self) -> tuple[float, float, float, float]: ...
    def translate(self, delta: Vector2Like) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def height(self) -> float: ...
    @property
    def max_x(self) -> float: ...
    @property
    def max_y(self) -> float: ...
    @property
    def min_x(self) -> float: ...
    @property
    def min_y(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...
    @property
    def width(self) -> float: ...
    @property
    def bounds(self) -> tuple[Vector2, Vector2]: ...

class CorridorScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    bidirectional: bool
    length: float
    width: float
    def __init__(self, width: typing.SupportsFloat = ..., length: typing.SupportsFloat = ..., agent_margin: typing.SupportsFloat = ..., add_safety_to_agent_margin: bool = ..., bidirectional: bool = ...) -> None: ...

class CrossScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    target_margin: float
    tolerance: float
    def __init__(self, side: typing.SupportsFloat = ..., tolerance: typing.SupportsFloat = ..., agent_margin: typing.SupportsFloat = ..., add_safety_to_agent_margin: bool = ..., target_margin: typing.SupportsFloat = ...) -> None: ...

class CrossTorusScenario(Scenario):
    add_safety_to_agent_margin: bool
    agent_margin: float
    side: float
    def __init__(self, side: typing.SupportsFloat = ..., agent_margin: typing.SupportsFloat = ..., add_safety_to_agent_margin: bool = ...) -> None: ...

class Dataset:
    dtype: numpy.dtype[Any]
    item_shape: list[int]
    def __init__(self, data: numpy.typing.ArrayLike | None = ..., dtype: numpy.typing.DTypeLike | None = ..., item_shape: collections.abc.Sequence[typing.SupportsInt] = ...) -> None: ...
    def append(self, values: numpy.typing.ArrayLike, reset: bool = ...) -> None: ...
    def get_buffer(self, index: typing.SupportsInt) -> navground.core._navground.Buffer: ...
    def push(self, value: typing.SupportsFloat) -> None: ...
    def reset(self) -> None: ...
    def write_buffer(self, buffer: navground.core._navground.Buffer, index: typing.SupportsInt) -> bool: ...
    def __buffer__(self, *args, **kwargs): ...  # type: ignore
    def __iter__(self) -> numpy.typing.NDArray[Any]: ...
    def __len__(self) -> int: ...
    def __release_buffer__(self, *args, **kwargs): ...  # type: ignore
    @property
    def is_valid(self) -> bool: ...
    @property
    def number_of_items(self) -> int: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def size(self) -> int: ...

class DirectionTask(Task):
    direction: Vector2
    def __init__(self, direction: Vector2Like = ...) -> None: ...

class DiscsStateEstimation(Sensor):
    include_valid: bool
    include_x: bool
    include_y: bool
    max_id: int
    max_radius: float
    max_speed: float
    number: int
    range: float
    use_nearest_point: bool
    def __init__(self, range: typing.SupportsFloat = ..., number: typing.SupportsInt = ..., max_radius: typing.SupportsFloat = ..., max_speed: typing.SupportsFloat = ..., include_valid: bool = ..., use_nearest_point: bool = ..., max_id: typing.SupportsInt = ..., include_x: bool = ..., include_y: bool = ..., name: str = ...) -> None: ...

class Entity:
    ignore_collisions: bool
    def has_been_in_collision_since(self, time: typing.SupportsFloat) -> bool: ...
    @staticmethod
    def reset_uid() -> None: ...
    @property
    def _uid(self) -> int: ...
    @property
    def last_collision_time(self) -> float: ...

class Experiment:
    def run_mp(experiment: Experiment,
               number_of_processes: int,
               keep: bool = ...,
               number_of_runs: int | None = ...,
               start_index: int | None = ...,
               callback: Callable[[int], None] | None = ...,
               bar: tqdm.tqdm[Any] | None = ...,
               scenario_init_callback: collections.abc.Callable[[Scenario, typing.SupportsInt], None] | None = ...,
               use_multiprocess: bool = ...,
               load_plugins: bool = True) -> None:  ...
    def setup_tqdm(self, bar: tqdm.tqdm[Any], number_of_runs: int | None = ...) -> None: ...
    _group_record_probes: dict[str, GroupRecordProbe]
    _probes: list[Probe]
    _record_probes: dict[str, RecordProbe]
    name: str
    number_of_runs: int
    record_config: RecordConfig
    record_scenario_properties: bool
    reset_uids: bool
    run_callbacks: dict[bool, list[collections.abc.Callable[[ExperimentalRun], None]]]
    run_index: int
    save_directory: pathlib.Path
    scenario: Scenario
    scenario_init_callback: collections.abc.Callable[[Scenario, typing.SupportsInt], None] | None
    steps: int
    terminate_when_all_idle_or_stuck: bool
    time_step: float
    def __init__(self, time_step: typing.SupportsFloat = ..., steps: typing.SupportsInt = ...) -> None: ...
    def add_group_record_probe(self, key: str, probe: collections.abc.Callable[[], GroupRecordProbe]) -> None: ...
    def add_probe(self, probe: collections.abc.Callable[[], Probe]) -> None: ...
    def add_record_probe(self, key: str, probe: collections.abc.Callable[[Dataset], RecordProbe]) -> None: ...
    def add_run(self, seed: typing.SupportsInt, run: ExperimentalRun) -> None: ...
    def add_run_callback(self, callback: collections.abc.Callable[[ExperimentalRun], None], at_init: bool = ...) -> None: ...
    def clear_run_callbacks(self) -> None: ...
    def dump(self) -> str: ...
    def get_run(self, index: typing.SupportsInt) -> ExperimentalRun: ...
    def init_run(self, seed: typing.SupportsInt, world: World = ...) -> ExperimentalRun: ...
    @staticmethod
    def load(value: str) -> Experiment | None: ...
    def remove_all_runs(self) -> None: ...
    def remove_run(self, seed: typing.SupportsInt) -> None: ...
    def run(self, keep: bool = ..., number_of_threads: typing.SupportsInt = ..., start_index: typing.SupportsInt | None = ..., number_of_runs: typing.SupportsInt | None = ..., data_path: os.PathLike[str] | str | bytes | None = ...) -> None: ...
    def run_once(self, seed: typing.SupportsInt) -> ExperimentalRun: ...
    def save(self, directory: os.PathLike[str] | str | bytes | None = ..., path: os.PathLike[str] | str | bytes | None = ...) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def start(self, path: os.PathLike[str] | str | bytes | None = ...) -> None: ...
    def start_run(self, run: ExperimentalRun) -> None: ...
    def stop(self, save_runs: bool = ...) -> None: ...
    def stop_run(self, run: ExperimentalRun) -> None: ...
    def update_run(self, run: ExperimentalRun) -> None: ...
    @property
    def begin_time(self) -> datetime.datetime: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def is_running(self) -> bool: ...
    @property
    def path(self) -> pathlib.Path | None: ...
    @property
    def runs(self) -> dict[int, ExperimentalRun]: ...

class ExperimentalRun:
    def __init__(self, world: World, time_step: typing.SupportsFloat = ..., steps: typing.SupportsInt = ..., terminate_when_all_idle_or_stuck: bool = ..., record_config: RecordConfig = ..., seed: typing.SupportsInt = ...) -> None: ...
    def add_group_record_probe(self, key: str, probe: collections.abc.Callable[[], GroupRecordProbe]) -> GroupRecordProbe: ...
    def add_probe(self, probe: Probe) -> None: ...
    def add_record(self, key: str, data: numpy.typing.ArrayLike | None = ..., dtype: object = ..., item_shape: collections.abc.Sequence[typing.SupportsInt] = ...) -> Dataset: ...
    def add_record_probe(self, key: str, probe: collections.abc.Callable[[Dataset], RecordProbe]) -> RecordProbe: ...
    @staticmethod
    def data_from_target(target: navground.core._navground.Target) -> list[float]: ...
    def get_collision_events(self, min_interval: typing.SupportsInt = ...) -> Dataset: ...
    def get_collisions_at_step(self, step: typing.SupportsInt) -> set[tuple[Entity, Entity]]: ...
    def get_record(self, key: str = ...) -> Dataset: ...
    def get_record_names(self, group: str = ...) -> set[str]: ...
    def get_records(self, group: str = ...) -> dict[str, Dataset]: ...
    def get_sensing_for(self, id: typing.SupportsInt) -> dict[str, Dataset]: ...
    def get_steps_to_collision(self, min_interval: typing.SupportsInt = ...) -> Dataset: ...
    def get_task_events(self, agent: Agent) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    def go_to_step(self, step: typing.SupportsInt, ignore_collisions: bool = ..., ignore_twists: bool = ..., ignore_cmds: bool = ..., ignore_targets: bool = ..., ignore_sensing: bool = ...) -> bool: ...
    def index_of_agent(self, agent: Agent) -> int | None: ...
    def reset(self) -> None: ...
    def run(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    @staticmethod
    def target_from_data(data: collections.abc.Sequence[typing.SupportsFloat]) -> navground.core._navground.Target: ...
    def update(self) -> None: ...
    @property
    def actuated_commands(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def bounding_box(self) -> BoundingBox: ...
    @property
    def collisions(self) -> numpy.typing.NDArray[numpy.int_]: ...
    @property
    def commands(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def deadlocks(self) -> numpy.typing.NDArray[numpy.int_]: ...
    @property
    def duration(self) -> datetime.timedelta: ...
    @property
    def efficacy(self) ->numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def final_sim_time(self) -> float: ...
    @property
    def has_finished(self) -> bool: ...
    @property
    def maximal_steps(self) -> int: ...
    @property
    def neighbors(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def poses(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def record_config(self) -> RecordConfig: ...
    @property
    def record_names(self) -> set[str]: ...
    @property
    def recorded_steps(self) -> int: ...
    @property
    def records(self) -> dict[str, Dataset]: ...
    @property
    def safety_violations(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def seed(self) -> int: ...
    @property
    def sensing(self) -> dict[int, dict[str, Dataset]]: ...
    @property
    def targets(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def task_events(self) -> dict[int, numpy.typing.NDArray[numpy.floating[Any]]]: ...
    @property
    def terminate_when_all_idle_or_stuck(self) -> bool: ...
    @property
    def time_step(self) -> float: ...
    @property
    def times(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def twists(self) -> numpy.typing.NDArray[numpy.floating[Any]]: ...
    @property
    def world(self) -> World: ...

class GoToPoseTask(WaypointsTask):
    orientation: float
    point: Vector2
    def __init__(self, point: Vector2Like = ..., orientation: typing.SupportsFloat = ..., tolerance: typing.SupportsFloat = ..., angular_tolerance: typing.SupportsFloat = ...) -> None: ...

class GroupRecordProbe(Probe):
    def __init__(self, factory: collections.abc.Callable[[str], Dataset] | None = ...) -> None: ...
    def get_data(self, key: str) -> Dataset: ...
    def get_shapes(self, world: World, use_agent_uid_as_key: bool) -> dict[str, list[int]]: ...

class LidarStateEstimation(Sensor):
    class Scan:
        fov: float
        max_range: float
        start_angle: float
        @property
        def angles(self) -> list[float]: ...
        @property
        def angular_increment(self) -> float: ...
        @property
        def ranges(self) -> list[float]: ...
    error_bias: float
    error_std_dev: float
    field_of_view: float
    position: Vector2
    range: float
    resolution: int
    start_angle: float
    def __init__(self, range: typing.SupportsFloat = ..., start_angle: typing.SupportsFloat = ..., field_of_view: typing.SupportsFloat = ..., resolution: typing.SupportsInt = ..., position: Vector2Like = ..., error_bias: typing.SupportsFloat = ..., error_std_dev: typing.SupportsFloat = ..., name: str = ...) -> None: ...
    def read_ranges(self, state: navground.core._navground.SensingState) -> list[float]: ...
    @staticmethod
    def read_ranges_with_name(state: navground.core._navground.SensingState, name: str) -> list[float]: ...
    def read_scan(self, state: navground.core._navground.SensingState) -> LidarStateEstimation.Scan | None: ...
    @staticmethod
    def read_scan_with_name(state: navground.core._navground.SensingState, name: str) -> LidarStateEstimation.Scan | None: ...
    @property
    def angles(self) -> list[float]: ...
    @property
    def angular_increment(self) -> float: ...

class LocalGridMapStateEstimation(Sensor):
    class FootprintType(enum.Enum):
        circular = ...
        none = ...
        rectangular = ...
    circular: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
    none: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
    rectangular: ClassVar[LocalGridMapStateEstimation.FootprintType] = ...
    external_lidars: list[str]
    external_odometry: str
    footprint: LocalGridMapStateEstimation.FootprintType
    height: int
    include_transformation: bool
    lidars: list[LidarStateEstimation]
    odometry: OdometryStateEstimation
    resolution: float
    width: int
    def __init__(self, lidars: collections.abc.Sequence[LidarStateEstimation] = ..., external_lidars: collections.abc.Sequence[str] = ..., odometry: OdometryStateEstimation = ..., external_odometry: str = ..., width: typing.SupportsInt = ..., height: typing.SupportsInt = ..., resolution: typing.SupportsFloat = ..., include_transformation: bool = ..., footprint: LocalGridMapStateEstimation.FootprintType = ..., name: str = ...) -> None: ...
    def read_gridmap(self, state: navground.core._navground.SensingState) -> navground.core._navground.GridMap | None: ...
    @staticmethod
    def read_gridmap_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.GridMap | None: ...
    def read_transform(self, state: navground.core._navground.SensingState) -> navground.core._navground.Pose2 | None: ...
    @staticmethod
    def read_transform_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.Pose2 | None: ...

class MarkerStateEstimation(Sensor):
    class ReferenceOrientation(enum.Enum):
        agent = ...
        target_direction = ...
        world = ...
    agent: ClassVar[MarkerStateEstimation.ReferenceOrientation] = ...
    target_direction: ClassVar[MarkerStateEstimation.ReferenceOrientation] = ...
    world: ClassVar[MarkerStateEstimation.ReferenceOrientation] = ...
    bounding_box: BoundingBox
    include_x: bool
    include_y: bool
    marker_position: Vector2
    max_x: float
    max_y: float
    min_x: float
    min_y: float
    reference_orientation: MarkerStateEstimation.ReferenceOrientation
    def __init__(self, marker_position: Vector2Like = ..., reference_orientation: MarkerStateEstimation.ReferenceOrientation = ..., min_x: typing.SupportsFloat = ..., min_y: typing.SupportsFloat = ..., max_x: typing.SupportsFloat = ..., max_y: typing.SupportsFloat = ..., include_x: bool = ..., include_y: bool = ..., name: str = ...) -> None: ...
    def read_marker_position(self, state: navground.core._navground.SensingState) -> Vector2 | None: ...
    @staticmethod
    def read_marker_position_with_name(state: navground.core._navground.SensingState, name: str) -> Vector2 | None: ...
    def update_marker(self, agent: Agent, world: World) -> None: ...
    @property
    def measured_marker_position(self) -> Vector2: ...

class NativeAgent(Entity, navground.core._navground.HasAttributes):
    angular_speed: float
    behavior: navground.core._navground.Behavior | None
    color: str
    control_period: float
    enabled: bool
    id: int
    kinematics: navground.core._navground.Kinematics | None
    last_cmd: navground.core._navground.Twist2
    orientation: float
    pose: navground.core._navground.Pose2
    position: Vector2
    radius: float
    state_estimation: StateEstimation | None
    state_estimations: list[StateEstimation]
    tags: set[str]
    task: Task | None
    twist: navground.core._navground.Twist2
    type: str
    velocity: Vector2
    def actuate(self, cmd: navground.core._navground.Twist2, time_step: typing.SupportsFloat) -> None: ...
    def add_tag(self, tag: str) -> None: ...
    def get_last_cmd(self, frame: navground.core._navground.Frame) -> navground.core._navground.Twist2: ...
    def has_been_stuck_since(self, time: typing.SupportsFloat) -> bool: ...
    def remove_tag(self, tag: str) -> None: ...
    @property
    def actuated_cmd(self) -> navground.core._navground.Twist2: ...
    @property
    def controller(self) -> navground.core._navground.Controller: ...
    @property
    def idle(self) -> bool: ...
    @property
    def time_since_stuck(self) -> float: ...

class NativeWorld(navground.core._navground.HasAttributes):
    bounding_box: BoundingBox
    collisions: set[tuple[Entity, Entity]]
    ignore_collisions: bool
    seed: int
    step: int
    time: float
    def _close(self) -> None: ...
    def _prepare(self) -> None: ...
    def __init__(self) -> None: ...
    def actuate(self, time_step: typing.SupportsFloat) -> None: ...
    def add_agent(self, agent: Agent) -> None: ...
    def add_callback(self, callback: collections.abc.Callable[[], None]) -> None: ...
    @overload
    def add_obstacle(self, disc: navground.core._navground.Disc) -> None: ...
    @overload
    def add_obstacle(self, obstacle: Obstacle) -> None: ...
    def add_random_obstacles(self, number: typing.SupportsInt, min_radius: typing.SupportsFloat, max_radius: typing.SupportsFloat, margin: typing.SupportsFloat = ..., max_tries: typing.SupportsInt = ...) -> None: ...
    @overload
    def add_wall(self, line: navground.core._navground.LineSegment) -> None: ...
    @overload
    def add_wall(self, wall: Wall) -> None: ...
    def agents_are_idle(self) -> bool: ...
    def agents_are_idle_or_stuck(self) -> bool: ...
    def clear_collisions(self) -> None: ...
    def compute_safety_violation(self, agent: Agent, safety_margin: typing.SupportsFloat | None = ...) -> float: ...
    def copy_random_generator(self, world: World) -> None: ...
    def dump(self) -> str: ...
    def get_agents_in_collision(self, duration: typing.SupportsFloat = ...) -> list[Agent]: ...
    def get_agents_in_deadlock(self, duration: typing.SupportsFloat = ...) -> list[Agent]: ...
    def get_agents_in_region(self, bounding_box: BoundingBox) -> list[Agent]: ...
    def get_discs_in_region(self, bounding_box: BoundingBox, ignore_lattice: bool = ...) -> list[navground.core._navground.Disc]: ...
    def get_entity(self, uid: typing.SupportsInt) -> Entity: ...
    def get_lattice(self, axis: typing.SupportsInt) -> tuple[float, float] | None: ...
    def get_lattice_grid(self, include_zero: bool = ..., c8: bool = ...) -> list[Vector2]: ...
    def get_line_obstacles_in_region(self, bounding_box: BoundingBox) -> list[navground.core._navground.LineSegment]: ...
    def get_neighbors(self, agent: Agent, distance: typing.SupportsFloat, ignore_lattice: bool = ...) -> list[navground.core._navground.Neighbor]: ...
    def get_obstacles_in_region(self, bounding_box: BoundingBox) -> list[Obstacle]: ...
    def in_collision(self, e1: Entity, e2: Entity) -> bool: ...
    def index_of_agent(self, agent: Agent) -> int | None: ...
    @staticmethod
    def load(value: str) -> World | None: ...
    def record_collision(self, e1: Entity, e2: Entity) -> None: ...
    def reset_callbacks(self) -> None: ...
    def run(self, steps: typing.SupportsInt, time_step: typing.SupportsFloat) -> None: ...
    def run_until(self, condition: collections.abc.Callable[[], bool], time_step: typing.SupportsFloat) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def set_lattice(self, axis: typing.SupportsInt, value: tuple[typing.SupportsFloat, typing.SupportsFloat] | None) -> None: ...
    def set_termination_condition(self, condition: collections.abc.Callable[[World], bool] | None) -> None: ...
    def should_terminate(self) -> bool: ...
    def snap_twists_to_zero(self, epsilon: typing.SupportsFloat = ...) -> None: ...
    def space_agents_apart(self, minimal_distance: typing.SupportsFloat = ..., with_safety_margin: bool = ..., max_iterations: typing.SupportsInt = ...) -> None: ...
    def subdivide_bounding_box(self, bounding_box: BoundingBox, ignore_lattice: bool = ...) -> list[tuple[Vector2, BoundingBox]]: ...
    def update(self, time_step: typing.SupportsFloat) -> None: ...
    def update_dry(self, time_step: typing.SupportsFloat, advance_time: bool = ...) -> None: ...
    @property
    def agents(self) -> list[Agent]: ...
    @property
    def discs(self) -> list[navground.core._navground.Disc]: ...
    @property
    def has_termination_condition(self) -> bool: ...
    @property
    def line_obstacles(self) -> list[navground.core._navground.LineSegment]: ...
    @property
    def minimal_bounding_box(self) -> BoundingBox: ...
    @property
    def obstacles(self) -> list[Obstacle]: ...
    @property
    def walls(self) -> list[Wall]: ...
    @property
    def bounds(self) -> tuple[Vector2, Vector2]: ...

class Obstacle(Entity):
    disc: navground.core._navground.Disc
    @overload
    def __init__(self, position: Vector2Like, radius: typing.SupportsFloat) -> None: ...
    @overload
    def __init__(self, disc: navground.core._navground.Disc) -> None: ...
    @overload
    def __init__(self, obstacle: Obstacle) -> None: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Obstacle | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class OdometryStateEstimation(Sensor):
    angular_speed_bias: float
    angular_speed_std_dev: float
    longitudinal_speed_bias: float
    longitudinal_speed_std_dev: float
    transversal_speed_bias: float
    transversal_speed_std_dev: float
    update_ego_state: bool
    update_sensing_state: bool
    def __init__(self, longitudinal_speed_bias: typing.SupportsFloat = ..., longitudinal_speed_std_dev: typing.SupportsFloat = ..., transversal_speed_bias: typing.SupportsFloat = ..., transversal_speed_std_dev: typing.SupportsFloat = ..., angular_speed_bias: typing.SupportsFloat = ..., angular_speed_std_dev: typing.SupportsFloat = ..., update_sensing_state: bool = ..., update_ego_state: bool = ..., name: str = ...) -> None: ...
    def read_pose(self, state: navground.core._navground.SensingState) -> navground.core._navground.Pose2 | None: ...
    @staticmethod
    def read_pose_with_name(state: navground.core._navground.SensingState, name: str) -> navground.core._navground.Pose2 | None: ...
    @property
    def pose(self) -> navground.core._navground.Pose2: ...
    @property
    def twist(self) -> navground.core._navground.Twist2: ...

class Probe:
    def __init__(self) -> None: ...
    def finalize(self, run: ExperimentalRun) -> None: ...
    def prepare(self, run: ExperimentalRun) -> None: ...
    def update(self, run: ExperimentalRun) -> None: ...

class RecordConfig:
    actuated_cmd: bool
    cmd: bool
    collisions: bool
    deadlocks: bool
    efficacy: bool
    neighbors: RecordNeighborsConfig
    pose: bool
    safety_violation: bool
    sensing: list[RecordSensingConfig]
    target: bool
    task_events: bool
    time: bool
    twist: bool
    use_agent_uid_as_key: bool
    world: bool
    def __init__(self, time: bool = ..., pose: bool = ..., twist: bool = ..., cmd: bool = ..., actuated_cmd: bool = ..., target: bool = ..., collisions: bool = ..., safety_violation: bool = ..., task_events: bool = ..., deadlocks: bool = ..., efficacy: bool = ..., world: bool = ..., neighbors: RecordNeighborsConfig = ..., use_agent_uid_as_key: bool = ..., sensing: collections.abc.Sequence[RecordSensingConfig] = ...) -> None: ...
    @staticmethod
    def all(value: bool) -> RecordConfig: ...
    def record_sensor(self, name: str, sensor: Sensor, agent_indices: collections.abc.Sequence[typing.SupportsInt]) -> None: ...
    def set_all(self, value: bool) -> None: ...

class RecordNeighborsConfig:
    enabled: bool
    number: int
    relative: bool
    def __init__(self, enabled: bool = ..., number: typing.SupportsInt = ..., relative: bool = ...) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class RecordProbe(Probe):
    def __init__(self, record: Dataset = ...) -> None: ...
    def get_shape(self, world: World) -> list[int]: ...
    @property
    def data(self) -> Dataset: ...

class RecordSensingConfig:
    agent_indices: list[int]
    name: str
    sensor: Sensor
    def __init__(self, name: str = ..., sensor: StateEstimation = ..., agent_indices: collections.abc.Sequence[typing.SupportsInt] = ...) -> None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class RunConfig:
    steps: int
    terminate_when_all_idle_or_stuck: bool
    time_step: float
    def __init__(self, time_step: typing.SupportsFloat = ..., steps: typing.SupportsInt = ..., terminate_when_all_idle_or_stuck: bool = ...) -> None: ...

class Sampler:
    once: bool
    def count(self) -> int: ...
    def done(self) -> bool: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str, type_name: str) -> Sampler: ...
    def reset(self, index: typing.SupportsInt | None = ..., keep: bool = ...) -> None: ...
    def sample(self, world: World) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    @property
    def type_name(self) -> str: ...

class Scenario(ScenarioRegister, navground.core._navground.HasProperties):
    class Group:
        def __init__(self) -> None: ...
        def add_to_world(self, world: World, seed: typing.SupportsInt | None = ...) -> None: ...
    bounding_box: BoundingBox | None
    ignore_collisions: bool
    obstacles: list[Obstacle]
    walls: list[Wall]
    def __init__(self) -> None: ...
    def add_group(self, group: object) -> None: ...
    def add_init(self, initializer: collections.abc.Callable[[World, typing.SupportsInt | None], None]) -> str: ...
    def add_property_sampler(self, name: str, value: Sampler) -> None: ...
    def apply_inits(self, world: World) -> None: ...
    def clear_groups(self) -> None: ...
    def clear_inits(self) -> None: ...
    def clear_property_samplers(self) -> None: ...
    def get_group(self, index: typing.SupportsInt) -> Scenario.Group: ...
    def init_world(self, world: World, seed: typing.SupportsInt | None = ...) -> None: ...
    @staticmethod
    def load(value: str) -> Scenario | None: ...
    def make_world(self, seed: typing.SupportsInt | None = ...) -> World: ...
    def remove_group(self, group: object) -> None: ...
    def remove_group_at_index(self, index: typing.SupportsInt) -> None: ...
    def remove_init(self, key: str) -> None: ...
    def remove_property_sampler(self, name: str) -> None: ...
    def set_attributes(self, world: World) -> None: ...
    def set_init(self, key: str, initializer: collections.abc.Callable[[World, typing.SupportsInt | None], None]) -> None: ...
    def set_yaml(self, value: str) -> None: ...
    @property
    def groups(self) -> list[Scenario.Group]: ...
    @property
    def inits(self) -> dict[str, collections.abc.Callable[[World, typing.SupportsInt | None], None]]: ...
    @property
    def property_samplers(self) -> dict[str, Sampler]: ...

class ScenarioRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Scenario | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...

class SensingProbe(Probe):
    def __init__(self, name: str = ..., sensor: Sensor = ..., agent_indices: collections.abc.Sequence[typing.SupportsInt] = ...) -> None: ...
    def get_data(self) -> dict[int, dict[str, Dataset]]: ...

class Sensor(StateEstimation):
    name: str
    def __init__(self, name: str = ...) -> None: ...
    def get_description(self) -> dict[str, navground.core._navground.BufferDescription]: ...
    def get_field_name(self, field: str) -> str: ...
    def get_or_init_buffer(self, state: navground.core._navground.SensingState, field: str) -> navground.core._navground.Buffer: ...
    @staticmethod
    def load(value: str) -> Sensor | None: ...
    def prepare_state(self, state: navground.core._navground.SensingState) -> None: ...
    @property
    def description(self) -> dict[str, navground.core._navground.BufferDescription]: ...

# class SensorCombination(Sensor):
#     sensors: list[Sensor]
#     def __init__(self, sensors: collections.abc.Sequence[Sensor] = ...) -> None: ...

class SimpleScenario(Scenario):
    def __init__(self) -> None: ...

class StateEstimation(StateEstimationRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    @staticmethod
    def load(value: str) -> StateEstimation | None: ...
    def prepare(self, agent: Agent, world: World) -> None: ...
    def update(self, agent: Agent, world: World, state: navground.core._navground.EnvironmentState) -> None: ...

class StateEstimationRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> StateEstimation | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...

class Task(TaskRegister, navground.core._navground.HasProperties):
    def __init__(self) -> None: ...
    def add_callback(self, callback: collections.abc.Callable[[collections.abc.Sequence[typing.SupportsFloat]], None]) -> None: ...
    def close(self) -> None: ...
    def done(self) -> bool: ...
    def get_log_size(self) -> int: ...
    @staticmethod
    def load(value: str) -> Task | None: ...
    def log_event(self, log: collections.abc.Sequence[typing.SupportsFloat]) -> None: ...
    def prepare(self, agent: Agent, world: World) -> None: ...
    def update(self, agent: Agent, world: World, time: typing.SupportsFloat) -> None: ...
    @property
    def log_size(self) -> int: ...

class TaskRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, navground.core._navground.Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Task | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, navground.core._navground.Property]: ...
    @property
    def type(self) -> str: ...

class Wall(Entity):
    line: navground.core._navground.LineSegment
    @overload
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    @overload
    def __init__(self, line: navground.core._navground.LineSegment) -> None: ...
    @overload
    def __init__(self, wall: Wall) -> None: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Wall | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class WaypointsTask(Task):
    angular_tolerance: float
    angular_tolerances: list[float]
    loop: bool
    orientations: list[float]
    random: bool
    tolerance: float
    tolerances: list[float]
    wait_time: float
    wait_times: list[float]
    waypoints: list[Vector2]
    def __init__(self, waypoints: collections.abc.Sequence[Vector2Like] = ..., loop: bool = ..., tolerance: typing.SupportsFloat = ..., random: bool = ..., tolerances: collections.abc.Sequence[typing.SupportsFloat] = ..., orientations: collections.abc.Sequence[typing.SupportsFloat] = ..., angular_tolerance: typing.SupportsFloat = ..., angular_tolerances: collections.abc.Sequence[typing.SupportsFloat] = ..., wait_time: typing.SupportsFloat = ..., wait_times: collections.abc.Sequence[typing.SupportsFloat] = ...) -> None: ...
    def get_effective_angular_tolerance(self, index: typing.SupportsInt) -> float: ...
    def get_effective_tolerance(self, index: typing.SupportsInt) -> float: ...
    def get_effective_wait_time(self, index: typing.SupportsInt) -> float: ...
    @property
    def log_size(self) -> int: ...

class World(NativeWorld):
    _repr_svg_: ClassVar[Callable[[World], str]] = ...
    render_kwargs: ClassVar[dict[str, Any]] = ...
    random_generator: numpy.random.Generator
    seed: int
    def __init__(self) -> None: ...
    def add_agent(self, agent: Agent) -> None: ...
    def copy_random_generator(self, world: World) -> None: ...

def bundle_schema() -> dict[str, Any]: ...
def get_build_dependencies() -> dict[str, navground.core._navground.DependencyInfo]: ...
def get_build_info() -> navground.core._navground.BuildInfo: ...
def use_compact_samplers(value: bool) -> None: ...
def uses_doubles() -> bool: ...
