import collections.abc
import datetime
import enum
import numpy
import numpy.typing
import os
import pathlib
import typing
from typing import Annotated, Any, ClassVar, TypeAlias, overload
from .types import FloatType

Vector2: TypeAlias = Annotated[numpy.typing.NDArray[FloatType], '[2, 1]']
Vector2Like: TypeAlias = Annotated[numpy.typing.ArrayLike, FloatType, '[2, 1]']

class Action:
    class State(enum.Enum):
        failure = ...
        idle = ...
        running = ...
        success = ...
    done_cb: collections.abc.Callable[[Action.State], None] | None
    running_cb: collections.abc.Callable[[typing.SupportsFloat], None] | None
    def abort(self) -> None: ...
    @property
    def done(self) -> bool: ...
    @property
    def running(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class AheadKinematics(Kinematics):
    def __init__(self, max_speed: typing.SupportsFloat = ..., max_angular_speed: typing.SupportsFloat = ...) -> None: ...

class Behavior(BehaviorRegister, HasProperties):
    class Heading(enum.Enum):
        idle = ...
        target_angle = ...
        target_angular_speed = ...
        target_point = ...
        velocity = ...
    actuated_twist: Twist2
    angular_speed: float
    assume_cmd_is_actuated: bool
    heading_behavior: Behavior.Heading
    horizon: float
    kinematics: Kinematics
    max_angular_speed: float
    max_speed: float
    optimal_angular_speed: float
    optimal_speed: float
    orientation: float
    path_look_ahead: float
    path_tau: float
    pose: Pose2
    position: Vector2
    radius: float
    rotation_tau: float
    safety_margin: float
    target: Target
    twist: Twist2
    velocity: Vector2
    wheel_speeds: list[float]
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...
    @overload
    def actuate(self, twist: Twist2, time_step: typing.SupportsFloat, enforce_feasibility: bool = ...) -> None: ...
    @overload
    def actuate(self, time_step: typing.SupportsFloat) -> None: ...
    def add_modulation(self, value: object) -> None: ...
    def check_if_target_satisfied(self) -> bool: ...
    def clear_modulations(self) -> None: ...
    def close(self) -> None: ...
    def cmd_twist_along_path(self, path: Path, speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_angular_speed(self, angular_speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_orientation(self, orientation: typing.SupportsFloat, angular_speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_point(self, point: Vector2Like, speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_pose(self, pose: Pose2, speed: typing.SupportsFloat, angular_speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_stopping(self, time_step: typing.SupportsFloat) -> Twist2: ...
    def cmd_twist_towards_velocity(self, velocity: Vector2Like, time_step: typing.SupportsFloat) -> Twist2: ...
    def compute_cmd(self, time_step: typing.SupportsFloat, frame: Frame | None = ..., enforce_feasibility: bool = ...) -> Twist2: ...
    def compute_cmd_internal(self, time_step: typing.SupportsFloat) -> Twist2: ...
    def desired_velocity_towards_point(self, point: Vector2Like, speed: typing.SupportsFloat, time_step: typing.SupportsFloat) -> Vector2: ...
    def desired_velocity_towards_velocity(self, velocity: Vector2Like, time_step: typing.SupportsFloat) -> Vector2: ...
    def estimate_time_until_target_satisfied(self) -> float: ...
    def feasible_angular_speed(self, value: typing.SupportsFloat) -> float: ...
    def feasible_speed(self, value: typing.SupportsFloat) -> float: ...
    def feasible_twist(self, value: Twist2) -> Twist2: ...
    def feasible_twist_from_current(self, value: Twist2, time_step: typing.SupportsFloat) -> Twist2: ...
    def get_actuated_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_environment_state(self) -> EnvironmentState: ...
    def get_target_angular_direction(self, ignore_tolerance: bool = ...) -> int | None: ...
    def get_target_angular_distance(self, ignore_tolerance: bool = ...) -> float: ...
    def get_target_angular_speed(self) -> float: ...
    def get_target_angular_velocity(self, ignore_tolerance: bool = ...) -> float: ...
    def get_target_direction(self, frame: Frame = ..., ignore_tolerance: bool = ...) -> Vector2 | None: ...
    def get_target_distance(self, ignore_tolerance: bool = ...) -> float: ...
    def get_target_orientation(self, frame: Frame, ignore_tolerance: bool = ...) -> float | None: ...
    def get_target_pose(self, frame: Frame = ..., ignore_tolerance: bool = ...) -> Pose2 | None: ...
    def get_target_position(self, frame: Frame = ..., ignore_tolerance: bool = ...) -> Vector2 | None: ...
    def get_target_speed(self) -> float: ...
    def get_target_twist(self, frame: Frame = ..., ignore_tolerance: bool = ...) -> Twist2: ...
    def get_target_velocity(self, frame: Frame = ..., ignore_tolerance: bool = ...) -> Vector2: ...
    def get_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_velocity(self, frame: Frame = ...) -> Vector2: ...
    def is_stopped(self, epsilon_speed: typing.SupportsFloat = ..., epsilon_angular_speed: typing.SupportsFloat = ...) -> bool: ...
    @staticmethod
    def load(value: str) -> Behavior | None: ...
    def prepare(self) -> None: ...
    def remove_modulation(self, value: object) -> None: ...
    def set_state_from(self, other: Behavior) -> None: ...
    def set_velocity(self, velocity: Vector2Like, frame: Frame = ...) -> None: ...
    def to_frame(self, value: Twist2, frame: Frame) -> Twist2: ...
    def twist_from_wheel_speeds(self, value: collections.abc.Sequence[typing.SupportsFloat]) -> Twist2: ...
    def twist_towards_velocity(self, velocity: Vector2Like) -> Twist2: ...
    def wheel_speeds_from_twist(self, value: Twist2) -> list[float]: ...
    @property
    def actuated_wheel_speeds(self) -> list[float]: ...
    @property
    def desired_velocity(self) -> Vector2: ...
    @property
    def efficacy(self) -> float: ...
    @property
    def environment_state(self) -> EnvironmentState: ...
    @property
    def has_target(self) -> bool: ...
    @property
    def is_stuck(self) -> bool: ...
    @property
    def modulations(self) -> list[BehaviorModulation]: ...
    @property
    def social_margin(self) -> SocialMargin: ...
    @property
    def speed(self) -> float: ...
    @property
    def target_ref(self) -> Target: ...

class BehaviorGroup:
    def __init__(self) -> None: ...
    def compute_cmds(self, time_step: typing.SupportsFloat) -> list[Twist2]: ...
    @property
    def members(self) -> list[Behavior]: ...
    @property
    def size(self) -> int: ...

class BehaviorGroupMember(Behavior):
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...
    def get_group_hash(self) -> int: ...
    def get_groups(self) -> dict[int, BehaviorGroup]: ...
    def make_group(self) -> BehaviorGroup: ...
    @property
    def group(self) -> BehaviorGroup: ...

class BehaviorModulation(BehaviorModulationRegister, HasProperties):
    enabled: bool
    def __init__(self) -> None: ...
    @staticmethod
    def load(value: str) -> BehaviorModulation | None: ...
    def post(self, behavior: Behavior, time_step: typing.SupportsFloat, cmd: Twist2) -> Twist2: ...
    def pre(self, behavior: Behavior, time_step: typing.SupportsFloat) -> None: ...

class BehaviorModulationRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> BehaviorModulation | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...

class BehaviorRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Behavior | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...

class BicycleKinematics(Kinematics):
    axis: float
    k: float
    max_backward_speed: float
    max_steering_angle: float
    use_velocity_norm: bool
    def __init__(self, max_speed: typing.SupportsFloat = ..., max_backward_speed: typing.SupportsFloat = ..., axis: typing.SupportsFloat = ..., max_steering_angle: typing.SupportsFloat = ..., k: typing.SupportsFloat = ..., use_velocity_norm: bool = ...) -> None: ...
    def feasible_steering_angle(self, arg0: Twist2) -> float: ...
    def twist_from_steering(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat) -> Twist2: ...
    @property
    def min_steering_radius(self) -> float: ...

class Buffer:
    categorical: bool
    data: numpy.typing.NDArray[Any]
    description: BufferDescription
    high: float
    low: float
    shape: tuple[int, ...]
    type: numpy.dtype[Any]
    def __init__(self, description: BufferDescription | None = ..., data: object = ...) -> None: ...
    def set_description(self, value: BufferDescription, force: bool = ...) -> bool: ...
    @property
    def size(self) -> int: ...

class BufferDescription:
    def __init__(self, shape: collections.abc.Sequence[typing.SupportsInt] = ..., dtype: numpy.typing.DTypeLike | None = ..., low: typing.SupportsFloat = ..., high: typing.SupportsFloat = ..., categorical: bool = ...) -> None: ...
    @property
    def categorical(self) -> bool: ...
    @property
    def high(self) -> float: ...
    @property
    def low(self) -> float: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def strides(self) -> list[int]: ...
    @property
    def type(self) -> numpy.dtype[Any]: ...

class BufferMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> Buffer: ...
    def __iter__(self) -> collections.abc.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: Buffer) -> None: ...

class BuildInfo:
    def to_string_diff(self, other: BuildInfo) -> str: ...
    @property
    def date(self) -> datetime.datetime: ...
    @property
    def date_string(self) -> str: ...
    @property
    def floating_point_type(self) -> str: ...
    @property
    def git(self) -> str: ...
    @property
    def version(self) -> list[int]: ...
    @property
    def version_string(self) -> str: ...

class CachedCollisionComputation(CollisionComputation):
    length: float
    max_distance: float
    min_angle: float
    resolution: int
    speed: float
    def __init__(self) -> None: ...
    def get_free_distance(self, dynamic: bool) -> list[float]: ...

class CollisionComputation:
    def __init__(self) -> None: ...
    def dynamic_free_distance(self, angle: typing.SupportsFloat, max_distance: typing.SupportsFloat, speed: typing.SupportsFloat) -> float: ...
    def get_angles_for_sector(self, from_angle: typing.SupportsFloat, length: typing.SupportsFloat, resolution: typing.SupportsInt) -> list[float]: ...
    def get_contour_for_sector(self, from_angle: typing.SupportsFloat, length: typing.SupportsFloat, resolution: typing.SupportsInt, max_distance: typing.SupportsFloat, dynamic: bool, speed: typing.SupportsFloat = ...) -> list[float]: ...
    def get_free_distance_for_sector(self, from_angle: typing.SupportsFloat, length: typing.SupportsFloat, resolution: typing.SupportsInt, max_distance: typing.SupportsFloat, dynamic: bool, speed: typing.SupportsFloat = ...) -> list[float]: ...
    def setup(self, pose: Pose2 = ..., margin: typing.SupportsFloat = ..., line_segments: collections.abc.Sequence[LineSegment] = ..., static_discs: collections.abc.Sequence[Disc] = ..., dynamic_discs: collections.abc.Sequence[Neighbor] = ...) -> None: ...
    def static_free_distance(self, angle: typing.SupportsFloat, max_distance: typing.SupportsFloat, include_neighbors: bool = ...) -> float: ...

class Controller:
    angular_speed_tolerance: float
    behavior: Behavior
    cmd_frame: Frame | None
    speed_tolerance: float
    def __init__(self, behavior: Behavior = ...) -> None: ...
    def follow_direction(self, direction: Vector2Like) -> Action: ...
    def follow_manual_cmd(self, cmd: Twist2) -> Action: ...
    def follow_path(self, path: Path, tolerance: typing.SupportsFloat) -> Action: ...
    def follow_point(self, point: Vector2Like) -> Action: ...
    def follow_pose(self, pose: Pose2) -> Action: ...
    def follow_twist(self, twist: Twist2) -> Action: ...
    def follow_velocity(self, velocity: Vector2Like) -> Action: ...
    def go_to_pose(self, pose: Pose2, position_tolerance: typing.SupportsFloat, orientation_tolerance: typing.SupportsFloat, along_path: Path | None = ...) -> Action: ...
    def go_to_position(self, position: Vector2Like, tolerance: typing.SupportsFloat, along_path: Path | None = ...) -> Action: ...
    def set_cmd_cb(self, callback: collections.abc.Callable[[Twist2], None]) -> None: ...
    def stop(self) -> None: ...
    def update(self, time_step: typing.SupportsFloat) -> Twist2: ...
    @property
    def idle(self) -> bool: ...
    @property
    def is_still(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class DependencyInfo:
    @property
    def build(self) -> BuildInfo: ...
    @property
    def run(self) -> BuildInfo: ...

class Disc:
    position: Vector2
    radius: float
    def __init__(self, position: Vector2Like, radius: typing.SupportsFloat) -> None: ...
    def distance(self, other: Disc) -> float: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Disc | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class DummyBehavior(Behavior):
    environment_state_type: str
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...
    def set_environment_state(self, state: EnvironmentState) -> None: ...

class DynamicTwoWheelsDifferentialDriveKinematics(TwoWheelsDifferentialDriveKinematics):
    max_acceleration: float
    max_angular_acceleration: float
    moi: float
    def __init__(self, max_speed: typing.SupportsFloat = ..., wheel_axis: typing.SupportsFloat = ..., max_angular_speed: typing.SupportsFloat = ..., max_forward_speed: typing.SupportsFloat = ..., max_backward_speed: typing.SupportsFloat = ..., max_acceleration: typing.SupportsFloat = ..., moi: typing.SupportsFloat = ...) -> None: ...
    def twist_from_wheel_torques(self, values: collections.abc.Sequence[typing.SupportsFloat], current: Twist2, time_step: typing.SupportsFloat) -> Twist2: ...
    def wheel_torques(self, value: Twist2, current: Twist2, time_step: typing.SupportsFloat) -> list[float]: ...
    @property
    def max_wheel_torque(self) -> float: ...

class EnvironmentState:
    def __init__(self) -> None: ...

class FourWheelsOmniDriveKinematics(WheeledKinematics):
    wheel_axis: float
    def __init__(self, max_speed: typing.SupportsFloat = ..., wheel_axis: typing.SupportsFloat = ...) -> None: ...

class Frame(enum.Enum):
    absolute = ...
    relative = ...

class GeometricState(EnvironmentState):
    line_obstacles: list[LineSegment]
    neighbors: list[Neighbor]
    static_obstacles: list[Disc]
    def __init__(self) -> None: ...

class GridMap:
    center: Vector2
    height: int
    origin: Vector2
    resolution: float
    width: int
    def __init__(self, width: typing.SupportsInt, height: typing.SupportsInt, resolution: typing.SupportsFloat, origin: Vector2Like = ...) -> None: ...
    def contains_point(self, point: Vector2Like) -> bool: ...
    def get_cell_at_position(self, position: Vector2Like, clamp: bool) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]']: ...
    def get_position_of_cell(self, cell: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]']) -> Vector2: ...
    def get_possible_cell_at_position(self, position: Vector2Like) -> typing.Annotated[numpy.typing.NDArray[numpy.int32], '[2, 1]'] | None: ...
    def move_center(self, position: Vector2Like, value: typing.SupportsInt = ..., snap: bool = ...) -> None: ...
    def move_origin(self, position: Vector2Like, value: typing.SupportsInt = ..., snap: bool = ...) -> None: ...
    def raytrace_between_cells(self, at: collections.abc.Callable[[typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]']], None], c1: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], c2: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], max_length: typing.SupportsInt = ..., min_length: typing.SupportsInt = ...) -> None: ...
    def set_value(self, value: typing.SupportsInt) -> None: ...
    def set_value_at_point(self, point: Vector2Like, value: typing.SupportsInt) -> None: ...
    def set_value_between_cells(self, c1: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], c2: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], value: typing.SupportsInt) -> None: ...
    def set_value_in_disc(self, center: Vector2Like, radius: typing.SupportsFloat, value: typing.SupportsInt) -> None: ...
    def set_value_in_rectangle(self, bottom_left: Vector2Like, width: typing.SupportsFloat, height: typing.SupportsFloat, value: typing.SupportsInt) -> None: ...
    def set_value_of_cell(self, cell: typing.Annotated[numpy.typing.ArrayLike, numpy.int32, '[2, 1]'], value: typing.SupportsInt) -> None: ...
    def set_value_on_line(self, p1: Vector2Like, p2: Vector2Like, value: typing.SupportsInt) -> None: ...
    @property
    def bottom_left(self) -> Vector2: ...
    @property
    def map(self) -> typing.Annotated[numpy.typing.NDArray[numpy.uint8], '[m, n]']: ...
    @property
    def top_right(self) -> Vector2: ...

class HLBehavior(Behavior):
    aperture: float
    barrier_angle: float
    epsilon: float
    eta: float
    resolution: int
    tau: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...
    def get_collision_distance(self, assuming_static: bool = ..., speed: typing.SupportsFloat | None = ...) -> list[float]: ...
    @property
    def angular_resolution(self) -> float: ...

class HRVOBehavior(Behavior):
    max_number_of_neighbors: int
    uncertainty_offset: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...

class HasAttributes:
    attributes: dict[str, bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]]
    def clear(self) -> None: ...
    def get(self, name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2] | None: ...
    def has(self, name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2] | None: ...
    def set(self, name: str, value: bool | typing.SupportsInt | typing.SupportsFloat | str | Vector2Like | collections.abc.Sequence[bool] | collections.abc.Sequence[typing.SupportsInt] | collections.abc.Sequence[typing.SupportsFloat] | collections.abc.Sequence[str] | collections.abc.Sequence[Vector2Like]) -> None: ...

class HasProperties:
    def get(self, name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    def get_property_type_name(self, name: str) -> str: ...
    def has(self, name: str) -> bool: ...
    def set(self, name: str, value: bool | typing.SupportsInt | typing.SupportsFloat | str | Vector2Like | collections.abc.Sequence[bool] | collections.abc.Sequence[typing.SupportsInt] | collections.abc.Sequence[typing.SupportsFloat] | collections.abc.Sequence[str] | collections.abc.Sequence[Vector2Like]) -> None: ...

class ItemsView:
    def __iter__(self) -> collections.abc.Iterator[tuple[str, Buffer]]: ...
    def __len__(self) -> int: ...

class KeysView:
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> collections.abc.Iterator[str]: ...
    def __len__(self) -> int: ...

class Kinematics(KinematicsRegister, HasProperties):
    max_angular_speed: float
    max_speed: float
    def __init__(self, max_speed: typing.SupportsFloat = ..., max_angular_speed: typing.SupportsFloat = ...) -> None: ...
    def dof(self) -> int: ...
    def feasible(self, twist: Twist2) -> Twist2: ...
    def feasible_from_current(self, twist: Twist2, current: Twist2, time_step: typing.SupportsFloat) -> Twist2: ...
    def get_max_angular_speed(self) -> float: ...
    def get_max_speed(self) -> float: ...
    def is_wheeled(self) -> bool: ...
    @staticmethod
    def load(value: str) -> Kinematics | None: ...

class KinematicsRegister:
    class_type: ClassVar[str] = ...  # read-only
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def dump(self) -> str: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Kinematics | None: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @classmethod
    def __init_subclass__(cls, name: str = ..., include_properties_of: list[str | type] = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...

class LimitAccelerationModulation(BehaviorModulation):
    max_acceleration: float
    max_angular_acceleration: float
    def __init__(self, max_acceleration: typing.SupportsFloat = ..., max_angular_acceleration: typing.SupportsFloat = ...) -> None: ...

class LimitTwistModulation(BehaviorModulation):
    max_angular_speed: float
    max_backward_speed: float
    max_forward_speed: float
    max_leftward_speed: float
    max_rightward_speed: float
    def __init__(self, forward: typing.SupportsFloat = ..., backward: typing.SupportsFloat = ..., leftward: typing.SupportsFloat = ..., rightward: typing.SupportsFloat = ..., angular: typing.SupportsFloat = ...) -> None: ...

class LineSegment:
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    def distance_along(self, point: Vector2Like, direction: Vector2Like, orientation: typing.SupportsInt = ...) -> float: ...
    def distance_from_disc(self, disc: Disc, penetration: bool = ...) -> float: ...
    def distance_from_point(self, point: Vector2Like) -> float: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> LineSegment | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    @property
    def e1(self) -> Vector2: ...
    @property
    def e2(self) -> Vector2: ...
    @property
    def length(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...

class MotorPIDModulation(BehaviorModulation):
    k_d: float
    k_i: float
    k_p: float
    def __init__(self, k_p: typing.SupportsFloat = ..., k_i: typing.SupportsFloat = ..., k_d: typing.SupportsFloat = ...) -> None: ...

class Neighbor(Disc):
    id: int
    velocity: Vector2
    def __init__(self, position: Vector2Like, radius: typing.SupportsFloat, velocity: Vector2Like = ..., id: typing.SupportsInt = ...) -> None: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Neighbor | None: ...
    def relative_to(self, reference: Pose2) -> Neighbor: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class ORCABehavior(Behavior):
    is_using_effective_center: bool
    max_number_of_neighbors: int
    static_time_horizon: float
    time_horizon: float
    treat_obstacles_as_agents: bool
    def __init__(self, kinematics: Kinematics | None = ..., radius: typing.SupportsFloat = ...) -> None: ...
    @property
    def lines(self) -> list[ORCALine]: ...

class ORCALine:
    @property
    def direction(self) -> Vector2: ...
    @property
    def point(self) -> Vector2: ...

class OmnidirectionalKinematics(Kinematics):
    def __init__(self, max_speed: typing.SupportsFloat = ..., max_angular_speed: typing.SupportsFloat = ...) -> None: ...

class Path:
    def __init__(self, project: collections.abc.Callable[[Vector2Like, typing.SupportsFloat, typing.SupportsFloat], float], curve: collections.abc.Callable[[typing.SupportsFloat], tuple[Vector2, float, float]], length: typing.SupportsFloat, loop: bool = ...) -> None: ...
    def get_point(self, position: Vector2Like, look_ahead: typing.SupportsFloat = ...) -> tuple[Vector2, float, float]: ...
    def track(self, position: Vector2Like, look_ahead: typing.SupportsFloat = ...) -> float: ...
    @property
    def coordinate(self) -> float: ...
    @property
    def curve(self) -> collections.abc.Callable[[typing.SupportsFloat], tuple[Vector2, float, float]]: ...
    @property
    def length(self) -> float: ...
    @property
    def loop(self) -> bool: ...
    @property
    def project(self) -> collections.abc.Callable[[Vector2Like, typing.SupportsFloat, typing.SupportsFloat], float]: ...

class Pose2:
    orientation: float
    position: Vector2
    def __init__(self, position: Vector2Like = ..., orientation: typing.SupportsFloat = ...) -> None: ...
    def absolute(self, reference: Pose2) -> Pose2: ...
    def get_transformation_in_frame(self, frame: Pose2) -> Pose2: ...
    def integrate(self, twist: Twist2, time_step: typing.SupportsFloat) -> Pose2: ...
    def inverse(self) -> Pose2: ...
    def relative(self, reference: Pose2) -> Pose2: ...
    def rotate(self, angle: typing.SupportsFloat) -> Pose2: ...
    def transform_point(self, point: Vector2Like) -> Vector2: ...
    def transform_pose(self, pose: Pose2) -> Pose2: ...
    def transform_vector(self, vector: Vector2Like) -> Vector2: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __mul__(self, arg0: Pose2) -> Pose2: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __truediv__(self, arg0: Pose2) -> Pose2: ...

class Property:
    def __init__(self, getter: object, setter: object, default: bool | typing.SupportsInt | typing.SupportsFloat | str | Vector2Like | collections.abc.Sequence[bool] | collections.abc.Sequence[typing.SupportsInt] | collections.abc.Sequence[typing.SupportsFloat] | collections.abc.Sequence[str] | collections.abc.Sequence[Vector2Like], type_name: str, description: str = ..., schema: collections.abc.Callable[[object], None] | None = ..., deprecated_names: collections.abc.Sequence[str] = ...) -> None: ...
    @staticmethod
    def make(property: object, default: bool | typing.SupportsInt | typing.SupportsFloat | str | Vector2Like | collections.abc.Sequence[bool] | collections.abc.Sequence[typing.SupportsInt] | collections.abc.Sequence[typing.SupportsFloat] | collections.abc.Sequence[str] | collections.abc.Sequence[Vector2Like], type_name: str, description: str = ..., schema: collections.abc.Callable[[object], None] | None = ..., deprecated_names: collections.abc.Sequence[str] = ...) -> Property: ...
    @staticmethod
    def make_prototype(type_name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2] | None: ...
    @property
    def default_value(self) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    @property
    def deprecated_names(self) -> list[str]: ...
    @property
    def description(self) -> str: ...
    @property
    def owner_type_name(self) -> str: ...
    @property
    def readonly(self) -> bool: ...
    @property
    def type_name(self) -> str: ...

class RelaxationModulation(BehaviorModulation):
    tau: float
    def __init__(self, tau: typing.SupportsFloat = ...) -> None: ...

class SensingState(EnvironmentState):
    def __init__(self) -> None: ...
    def get_buffer(self, key: str) -> Buffer: ...
    def init_buffer(self, key: str, description: BufferDescription | None = ..., data: object = ...) -> Buffer: ...
    def set_buffer(self, key: str, buffer: Buffer) -> None: ...
    @property
    def buffers(self) -> BufferMap: ...

class SocialMargin:
    modulation: SocialMarginModulation
    def __init__(self, value: typing.SupportsFloat = ...) -> None: ...
    def get(self, type: typing.SupportsInt | None = ..., distance: typing.SupportsFloat | None = ...) -> float: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def set(self, value: typing.SupportsFloat, type: typing.SupportsInt | None = ...) -> None: ...
    @property
    def max_value(self) -> float: ...

class SocialMarginConstantModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class SocialMarginLinearModulation(SocialMarginModulation):
    def __init__(self, upper_distance: typing.SupportsFloat) -> None: ...

class SocialMarginLogisticModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class SocialMarginModulation:
    def __call__(self, margin: typing.SupportsFloat, distance: typing.SupportsFloat | None = ...) -> float: ...

class SocialMarginQuadraticModulation(SocialMarginModulation):
    def __init__(self, upper_distance: typing.SupportsFloat) -> None: ...

class SocialMarginZeroModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class Target:
    angular_direction: int | None
    angular_speed: float | None
    direction: Vector2 | None
    orientation: float | None
    orientation_tolerance: float
    path: Path | None
    position: Vector2 | None
    position_tolerance: float
    speed: float | None
    def __init__(self, position: Vector2Like | None = ..., orientation: typing.SupportsFloat | None = ..., speed: typing.SupportsFloat | None = ..., direction: Vector2Like | None = ..., angular_speed: typing.SupportsFloat | None = ..., path: typing.SupportsInt | None = ..., angular_direction: Path | None = ..., position_tolerance: typing.SupportsFloat = ..., orientation_tolerance: typing.SupportsFloat = ...) -> None: ...
    @staticmethod
    def Direction(direction: Vector2Like) -> Target: ...
    @staticmethod
    def Orientation(orientation: typing.SupportsFloat, tolerance: typing.SupportsFloat = ...) -> Target: ...
    @staticmethod
    def Point(point: Vector2Like, tolerance: typing.SupportsFloat = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Pose(pose: Pose2, position_tolerance: typing.SupportsFloat = ..., orientation_tolerance: typing.SupportsFloat = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Stop() -> Target: ...
    @staticmethod
    def Twist(twist: Twist2) -> Target: ...
    @staticmethod
    def Velocity(velocity: Vector2Like) -> Target: ...
    def satisfied(self, point: Vector2Like) -> bool: ...
    @property
    def valid(self) -> bool: ...

class Twist2:
    angular_speed: float
    frame: Frame
    velocity: Vector2
    def __init__(self, velocity: Vector2Like = ..., angular_speed: typing.SupportsFloat = ..., frame: Frame = ...) -> None: ...
    def absolute(self, reference: Pose2) -> Twist2: ...
    def interpolate(self, target: Twist2, time_step: typing.SupportsFloat, max_acceleration: typing.SupportsFloat, max_angular_acceleration: typing.SupportsFloat) -> Twist2: ...
    def is_almost_zero(self, epsilon_speed: typing.SupportsFloat = ..., epsilon_angular_speed: typing.SupportsFloat = ...) -> bool: ...
    def relative(self, reference: Pose2) -> Twist2: ...
    def rotate(self, angle: typing.SupportsFloat) -> Twist2: ...
    def snap_to_zero(self, epsilon: typing.SupportsFloat = ...) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class TwoWheelsDifferentialDriveKinematics(WheeledKinematics):
    max_backward_speed: float
    max_forward_speed: float
    wheel_axis: float
    def __init__(self, max_speed: typing.SupportsFloat = ..., wheel_axis: typing.SupportsFloat = ..., max_angular_speed: typing.SupportsFloat = ..., max_forward_speed: typing.SupportsFloat = ..., max_backward_speed: typing.SupportsFloat = ...) -> None: ...
    @property
    def can_move_backwards(self) -> bool: ...
    @property
    def can_move_forwards(self) -> bool: ...

class ValuesView:
    def __iter__(self) -> collections.abc.Iterator[Buffer]: ...
    def __len__(self) -> int: ...

class WheeledKinematics(Kinematics):
    def feasible_wheel_speeds(self, value: Twist2) -> list[float]: ...
    def twist(self, value: collections.abc.Sequence[typing.SupportsFloat]) -> Twist2: ...
    def wheel_speeds(self, value: Twist2) -> list[float]: ...

def behavior_has_geometric_state(behavior: Behavior) -> bool: ...
def bundle_schema() -> dict[str, Any]: ...
def clamp_norm(vector: Vector2Like, max_length: typing.SupportsFloat) -> Vector2: ...
def convert(value: bool | typing.SupportsInt | typing.SupportsFloat | str | Vector2Like | collections.abc.Sequence[bool] | collections.abc.Sequence[typing.SupportsInt] | collections.abc.Sequence[typing.SupportsFloat] | collections.abc.Sequence[str] | collections.abc.Sequence[Vector2Like], scalar_type_name: str, is_list: bool) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2] | None: ...
def get_build_dependencies() -> dict[str, DependencyInfo]: ...
def get_build_info() -> BuildInfo: ...
def get_loaded_plugins() -> dict[str, dict[str, list[str]]]: ...
def get_plugins_dependencies() -> dict[str, dict[pathlib.Path, dict[str, DependencyInfo]]]: ...
def get_scalar_type_name(type_name: str) -> tuple[str, bool]: ...
def get_type_name_with_scalar(scalar_type_name: str, is_list: bool) -> str: ...
def load_plugins(plugins: collections.abc.Set[os.PathLike[str] | str | bytes] = ..., directories: collections.abc.Mapping[os.PathLike[str] | str | bytes, collections.abc.Set[os.PathLike[str] | str | bytes]] = ..., include_default: bool = ...) -> None: ...
def make_properties(cls: object, owner: str = ...) -> dict[str, Property]: ...
def normalize_angle(angle: typing.SupportsFloat) -> float: ...
def orientation_of(vector: Vector2Like) -> float: ...
def rotate(vector: Vector2Like, angle: typing.SupportsFloat) -> Vector2: ...
def to_absolute(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_absolute_point(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_relative(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_relative_point(value: Vector2Like, reference: Pose2) -> Vector2: ...
def unit(angle: typing.SupportsFloat) -> Vector2: ...
def uses_doubles() -> bool: ...
