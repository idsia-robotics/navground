import numpy
import os
import pathlib
import datetime
import abc
from collections.abc import Callable, Iterator
from typing import Any, ClassVar, overload, Literal, TypeAlias

Vector2: TypeAlias = numpy.ndarray[tuple[Literal[2]], numpy.dtype[numpy.float64]]
Vector2Like: TypeAlias = Vector2 | tuple[float, float] | list[float]


class Action:
    class State:
        __members__: ClassVar[dict[str, Action.State]] = ...  # read-only
        __entries: ClassVar[dict[str, tuple[Action.State, str]]] = ...
        failure: ClassVar[Action.State] = ...
        idle: ClassVar[Action.State] = ...
        running: ClassVar[Action.State] = ...
        success: ClassVar[Action.State] = ...
        def __init__(self, value: int) -> None: ...
        def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    done_cb: Callable[[Action.State], None] | None
    running_cb: Callable[[float], None] | None
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def abort(self) -> None: ...
    @property
    def done(self) -> bool: ...
    @property
    def running(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class AheadKinematics(Kinematics):
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dof(self) -> int: ...
    def feasible(self, twist: Twist2) -> Twist2: ...

class Behavior(BehaviorRegister, HasProperties):
    class Heading:
        __members__: ClassVar[dict[str, Behavior.Heading]] = ...  # read-only
        __entries: ClassVar[dict[str, tuple[Behavior.Heading, str]]] = ...
        idle: ClassVar[Behavior.Heading] = ...
        target_angle: ClassVar[Behavior.Heading] = ...
        target_angular_speed: ClassVar[Behavior.Heading] = ...
        target_point: ClassVar[Behavior.Heading] = ...
        velocity: ClassVar[Behavior.Heading] = ...
        def __init__(self, value: int) -> None: ...
        def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    actuated_twist: Twist2
    angular_speed: float
    assume_cmd_is_actuated: bool
    heading_behavior: Behavior.Heading
    horizon: float
    kinematics: Kinematics
    max_angular_speed: float
    max_speed: float
    optimal_angular_speed: float
    optimal_speed: float
    orientation: float
    path_look_ahead: float
    path_tau: float
    pose: Pose2
    position: Vector2
    radius: float
    rotation_tau: float
    safety_margin: float
    target: Target
    twist: Twist2
    velocity: Vector2
    wheel_speeds: list[float]
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @overload
    def actuate(self, twist: Twist2, time_step: float, enforce_feasibility: bool = ...) -> None: ...
    @overload
    def actuate(self, time_step: float) -> None: ...
    def add_modulation(self, value: object) -> None: ...
    def check_if_target_satisfied(self) -> bool: ...
    def clear_modulations(self) -> None: ...
    def cmd_twist_along_path(self, path: Path, speed: float, time_step: float) -> Twist2: ...
    def cmd_twist_towards_angular_speed(self, angular_speed: float, time_step: float) -> Twist2: ...
    def cmd_twist_towards_orientation(self, orientation: float, angular_speed: float, time_step: float) -> Twist2: ...
    def cmd_twist_towards_point(self, point: Vector2, speed: float, time_step: float) -> Twist2: ...
    def cmd_twist_towards_pose(self, pose: Pose2, speed: float, angular_speed: float, time_step: float) -> Twist2: ...
    def cmd_twist_towards_stopping(self, time_step: float) -> Twist2: ...
    def cmd_twist_towards_velocity(self, velocity: Vector2, time_step: float) -> Twist2: ...
    def compute_cmd(self, time_step: float, frame: Frame | None = ..., enforce_feasibility: bool = ...) -> Twist2: ...
    def compute_cmd_internal(self, time_step: float) -> Twist2: ...
    def desired_velocity_towards_point(self, point: Vector2, speed: float, time_step: float) -> Vector2: ...
    def desired_velocity_towards_velocity(self, velocity: Vector2, time_step: float) -> Vector2: ...
    def dump(self) -> str: ...
    def estimate_time_until_target_satisfied(self) -> float: ...
    def feasible_angular_speed(self, value: float) -> float: ...
    def feasible_speed(self, value: float) -> float: ...
    def feasible_twist(self, value: Twist2) -> Twist2: ...
    def feasible_twist_from_current(self, value: Twist2, time_step: float) -> Twist2: ...
    def get_actuated_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_environment_state(self) -> EnvironmentState: ...
    def get_target_angular_speed(self) -> float: ...
    def get_target_direction(self, frame: Frame = ...) -> Vector2 | None: ...
    def get_target_distance(self, ignore_tolerance: bool = ...) -> float | None: ...
    def get_target_orientation(self, frame: Frame) -> float | None: ...
    def get_target_position(self, frame: Frame = ...) -> Vector2 | None: ...
    def get_target_speed(self) -> float: ...
    def get_target_velocity(self, frame: Frame = ...) -> Vector2: ...
    def get_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_velocity(self, frame: Frame = ...) -> Vector2: ...
    @staticmethod
    def load(value: str) -> Behavior | None: ...
    def remove_modulation(self, value: object) -> None: ...
    def set_state_from(self, other: Behavior) -> None: ...
    def set_velocity(self, velocity: Vector2Like, frame: Frame = ...) -> None: ...
    def to_frame(self, value: Twist2, frame: Frame) -> Twist2: ...
    def twist_from_wheel_speeds(self, value: list[float]) -> Twist2: ...
    def twist_towards_velocity(self, velocity: Vector2Like) -> Twist2: ...
    def wheel_speeds_from_twist(self, value: Twist2) -> list[float]: ...
    @property
    def actuated_wheel_speeds(self) -> list[float]: ...
    @property
    def desired_velocity(self) -> Vector2: ...
    @property
    def efficacy(self) -> float: ...
    @property
    def environment_state(self) -> EnvironmentState: ...
    @property
    def is_stuck(self) -> bool: ...
    @property
    def modulations(self) -> list[BehaviorModulation]: ...
    @property
    def social_margin(self) -> SocialMargin: ...
    @property
    def speed(self) -> float: ...
    @property
    def target_ref(self) -> Target: ...

class BehaviorModulation(BehaviorModulationRegister, HasProperties):
    enabled: bool
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> BehaviorModulation | None: ...
    def post(self, behavior: Behavior, time_step: float, cmd: Twist2) -> Twist2: ...
    def pre(self, behavior: Behavior, time_step: float) -> None: ...

class BehaviorModulationRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> BehaviorModulation | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...

class BehaviorRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Behavior | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...

class BuildInfo:
    @property
    def version(self) -> list[int]: ...
    @property
    def git(self) -> str: ...
    @property
    def date(self) -> datetime.datetime: ...
    @property
    def floating_point_type(self) -> str: ...
    @property
    def version_string(self) -> str: ...
    @property
    def date_string(self) -> str: ...
    def to_string_diff(self, other: BuildInfo) -> str: ...

class DependencyInfo:
    @property
    def build(self) -> BuildInfo: ...
    @property
    def run(self) -> BuildInfo: ...

class Buffer:
    categorical: bool
    data: numpy.typing.NDArray[Any]
    description: BufferDescription
    high: float
    low: float
    shape: tuple[int]
    type: numpy.dtype[Any]
    def __init__(self, description: BufferDescription | None = ..., data: object = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_description(self, value: BufferDescription, force: bool = ...) -> bool: ...
    @property
    def size(self) -> int: ...

class BufferDescription:
    def __init__(self, shape: list[int] = ..., dtype: numpy.typing.DTypeLike | None = ..., low: float = ..., high: float = ..., categorical: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def categorical(self) -> bool: ...
    @property
    def high(self) -> float: ...
    @property
    def low(self) -> float: ...
    @property
    def shape(self) -> tuple[int]: ...
    @property
    def strides(self) -> list[int]: ...
    @property
    def type(self) -> numpy.dtype[Any]: ...

class BufferMap:
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> Buffer: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: Buffer) -> None: ...

class CachedCollisionComputation(CollisionComputation):
    length: float
    max_distance: float
    min_angle: float
    resolution: int
    speed: float
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_free_distance(self, dynamic: bool) -> list[float]: ...

class CollisionComputation:
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dynamic_free_distance(self, angle: float, max_distance: float, speed: float) -> float: ...
    def get_angles_for_sector(self, from_angle: float, length: float, resolution: int) -> list[float]: ...
    def get_contour_for_sector(self, from_angle: float, length: float, resolution: int, max_distance: float, dynamic: bool, speed: float = ...) -> list[float]: ...
    def get_free_distance_for_sector(self, from_angle: float, length: float, resolution: int, max_distance: float, dynamic: bool, speed: float = ...) -> list[float]: ...
    def setup(self, pose: Pose2 = ..., margin: float = ..., line_segments: list[LineSegment] = ..., static_discs: list[Disc] = ..., dynamic_discs: list[Neighbor] = ...) -> None: ...
    def static_free_distance(self, angle: float, max_distance: float, include_neighbors: bool = ...) -> float: ...

class Controller:
    behavior: Behavior
    cmd_frame: Frame | None
    speed_tolerance: float
    def __init__(self, behavior: Behavior = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def follow_direction(self, direction: Vector2Like) -> Action: ...
    def follow_manual_cmd(self, cmd: Twist2) -> Action: ...
    def follow_path(self, path: Path, tolerance: float) -> Action: ...
    def follow_point(self, point: Vector2Like) -> Action: ...
    def follow_pose(self, pose: Pose2) -> Action: ...
    def follow_twist(self, twist: Twist2) -> Action: ...
    def follow_velocity(self, velocity: Vector2Like) -> Action: ...
    def go_to_pose(self, pose: Pose2, position_tolerance: float, orientation_tolerance: float, along_path: Path | None = ...) -> Action: ...
    def go_to_position(self, position: Vector2Like, tolerance: float, along_path: Path | None = ...) -> Action: ...
    def set_cmd_cb(self, callback: Callable[[Twist2], None]) -> None: ...
    def stop(self) -> None: ...
    def update(self, time_step: float) -> Twist2: ...
    @property
    def idle(self) -> bool: ...
    @property
    def is_still(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class Disc:
    position: Vector2
    radius: float
    def __init__(self, position: Vector2Like, radius: float) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def distance(self, other: Disc) -> float: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Disc | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...

class DummyBehavior(Behavior):
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_environment_state(self, state: EnvironmentState) -> None: ...
    @property
    def environment_state_type(self) -> str: ...

class DynamicTwoWheelsDifferentialDriveKinematics(TwoWheelsDifferentialDriveKinematics):
    max_acceleration: float
    max_angular_acceleration: float
    moi: float
    def __init__(self, max_speed: float = ..., wheel_axis: float = ..., max_angular_speed: float = ..., max_forward_speed: float = ..., max_backward_speed: float = ..., max_acceleration: float = ..., moi: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def twist_from_wheel_torques(self, values: list[float], current: Twist2, time_step: float) -> Twist2: ...
    def wheel_torques(self, value: Twist2, current: Twist2, time_step: float) -> list[float]: ...
    @property
    def max_wheel_torque(self) -> float: ...

class EnvironmentState:
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class FourWheelsOmniDriveKinematics(WheeledKinematics):
    wheel_axis: float
    def __init__(self, max_speed: float = ..., wheel_axis: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dof(self) -> int: ...
    def feasible(self, twist: Twist2) -> Twist2: ...
    def twist(self, value: list[float]) -> Twist2: ...
    def wheel_speeds(self, value: Twist2) -> list[float]: ...

class Frame:
    __members__: ClassVar[dict[str, Frame]] = ...  # read-only
    __entries: ClassVar[dict[str, tuple[Frame, str]]] = ...
    absolute: ClassVar[Frame] = ...
    relative: ClassVar[Frame] = ...
    def __init__(self, value: int) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GeometricState(EnvironmentState):
    line_obstacles: list[LineSegment]
    neighbors: list[Neighbor]
    static_obstacles: list[Disc]
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class HLBehavior(Behavior):
    aperture: float
    barrier_angle: float
    epsilon: float
    eta: float
    resolution: int
    tau: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_collision_distance(self, assuming_static: bool = ..., speed: float | None = ...) -> list[float]: ...
    @property
    def angular_resolution(self) -> float: ...

class HRVOBehavior(Behavior):
    max_number_of_neighbors: int
    uncertainty_offset: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class HasProperties:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get(self, name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    def set(self, name: str, value: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]) -> None: ...

class ItemsView:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def __iter__(self) -> Iterator[tuple[str, Buffer]]: ...
    def __len__(self) -> int: ...

class KeysView:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...

class Kinematics(abc.ABC, KinematicsRegister, HasProperties):
    max_angular_speed: float
    max_speed: float
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @abc.abstractmethod
    def dof(self) -> int: ...
    def dump(self) -> str: ...
    @abc.abstractmethod
    def feasible(self, twist: Twist2) -> Twist2: ...
    def feasible_from_current(self, twist: Twist2, current: Twist2, time_step: float) -> Twist2: ...
    def get_max_angular_speed(self) -> float: ...
    def get_max_speed(self) -> float: ...
    def is_wheeled(self) -> bool: ...
    @staticmethod
    def load(value: str) -> Kinematics | None: ...

class KinematicsRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Kinematics | None: ...
    @classmethod
    def __init_subclass__(cls, name: str = ...) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...
    @property
    def type(self) -> str: ...
    @staticmethod
    def schema(reference_register_schema: bool = ..., type: str | None = ...) -> dict[str, Any]: ...
    @staticmethod
    def register_schema() -> dict[str, Any]: ...

class LimitAccelerationModulation(BehaviorModulation):
    max_acceleration: float
    max_angular_acceleration: float
    def __init__(self, max_acceleration: float = ..., max_angular_acceleration: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class LimitTwistModulation(BehaviorModulation):
    max_angular_speed: float
    max_backward_speed: float
    max_forward_speed: float
    max_leftward_speed: float
    max_rightward_speed: float
    def __init__(self, forward: float = ..., backward: float = ..., leftward: float = ..., rightward: float = ..., angular: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class LineSegment:
    def __init__(self, p1: Vector2Like, p2: Vector2Like) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def distance_along(self, point: Vector2Like, direction: Vector2Like, orientation: int = ...) -> float: ...
    def distance_from_disc(self, disc: Disc, penetration: bool = ...) -> float: ...
    def distance_from_point(self, point: Vector2Like) -> float: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> LineSegment | None: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    @property
    def e1(self) -> Vector2: ...
    @property
    def e2(self) -> Vector2: ...
    @property
    def length(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...

class MotorPIDModulation(BehaviorModulation):
    k_d: float
    k_i: float
    k_p: float
    def __init__(self, k_p: float = ..., k_i: float = ..., k_d: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class Neighbor(Disc):
    id: int
    velocity: Vector2
    def __init__(self, position: Vector2Like, radius: float, velocity: Vector2Like = ..., id: int = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dump(self) -> str: ...
    @staticmethod
    def load(value: str) -> Neighbor | None: ...
    def relative_to(self, reference: Pose2) -> Neighbor: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class ORCABehavior(Behavior):
    is_using_effective_center: bool
    max_number_of_neighbors: int
    static_time_horizon: float
    time_horizon: float
    treat_obstacles_as_agents: bool
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def lines(self) -> list[ORCALine]: ...

class ORCALine:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def direction(self) -> Vector2: ...
    @property
    def point(self) -> Vector2: ...

class OmnidirectionalKinematics(Kinematics):
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def dof(self) -> int: ...
    def feasible(self, twist: Twist2) -> Twist2: ...

class Path:
    def __init__(self, project: Callable[[Vector2, float, float], float], curve: Callable[[float], tuple[Vector2, float, float]], length: float, loop: bool = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_point(self, position: Vector2Like, look_ahead: float = ...) -> tuple[Vector2, float, float]: ...
    def track(self, position: Vector2Like, look_ahead: float = ...) -> float: ...
    @property
    def coordinate(self) -> float: ...
    @property
    def curve(self) -> Callable[[float], tuple[Vector2, float, float]]: ...
    @property
    def length(self) -> float: ...
    @property
    def loop(self) -> bool: ...
    @property
    def project(self) -> Callable[[Vector2, float, float], float]: ...

class Pose2:
    orientation: float
    position: Vector2
    def __init__(self, position: Vector2Like = ..., orientation: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def absolute(self, reference: Pose2) -> Pose2: ...
    # @overload
    def get_transformation_in_frame(self, frame: Pose2) -> Pose2: ...
    # @overload
    # def get_transformation_in_frame(self, frame) -> Any: ...
    def integrate(self, twist: Twist2, time_step: float) -> Pose2: ...
    def inverse(self) -> Pose2: ...
    def relative(self, reference: Pose2) -> Pose2: ...
    def rotate(self, angle: float) -> Pose2: ...
    def transform_point(self, point: Vector2Like) -> Vector2: ...
    def transform_pose(self, pose: Pose2) -> Pose2: ...
    def transform_vector(self, vector: Vector2Like) -> Vector2: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __mul__(self, arg0: object) -> Pose2: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __truediv__(self, arg0: object) -> Pose2: ...

class Property:
    def __init__(self, getter: object, setter: object, default: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], description: str = ..., deprecated_names: list[str] = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @staticmethod
    def make(property: property, default: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], description: str = ..., deprecated_names: list[str] = ...) -> Property: ...
    @property
    def default_value(self) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    @property
    def deprecated_names(self) -> list[str]: ...
    @property
    def description(self) -> str: ...
    @property
    def owner_type_name(self) -> str: ...
    @property
    def readonly(self) -> bool: ...
    @property
    def type_name(self) -> str: ...

class RelaxationModulation(BehaviorModulation):
    tau: float
    def __init__(self, tau: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class SensingState(EnvironmentState):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_buffer(self, key: str) -> Buffer: ...
    def init_buffer(self, key: str, description: BufferDescription | None = ..., data: numpy.typing.NDArray[Any] = ...) -> Buffer: ...
    def set_buffer(self, key: str, buffer: Buffer) -> None: ...
    @property
    def buffers(self) -> BufferMap: ...

class SocialMargin:
    modulation: SocialMarginModulation
    def __init__(self, value: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def get(self, type: int | None = ..., distance: float | None = ...) -> float: ...
    @staticmethod
    def schema() -> dict[str, Any]: ...
    def set(self, value: float, type: int | None = ...) -> None: ...
    @property
    def max_value(self) -> float: ...

class SocialMarginConstantModulation(SocialMarginModulation):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class SocialMarginLinearModulation(SocialMarginModulation):
    def __init__(self, upper_distance: float) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class SocialMarginLogisticModulation(SocialMarginModulation):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class SocialMarginModulation:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def __call__(self, margin: float, distance: float | None = ...) -> float: ...

class SocialMarginQuadraticModulation(SocialMarginModulation):
    def __init__(self, upper_distance: float) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class SocialMarginZeroModulation(SocialMarginModulation):
    def __init__(self) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...

class Target:
    angular_speed: float | None
    direction: Vector2 | None
    orientation: float | None
    orientation_tolerance: float
    path: Path | None
    position: Vector2 | None
    position_tolerance: float
    speed: float | None
    def __init__(self, position: Vector2Like | None = ..., orientation: float | None = ..., speed: float | None = ..., direction: Vector2Like | None = ..., angular_speed: float | None = ..., path: Path | None = ..., position_tolerance: float = ..., orientation_tolerance: float = ...) -> None: ...
    @staticmethod
    def Direction(direction: Vector2Like) -> Target: ...
    @staticmethod
    def Orientation(orientation: float, tolerance: float = ...) -> Target: ...
    @staticmethod
    def Point(point: Vector2Like, tolerance: float = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Pose(pose: Pose2, position_tolerance: float = ..., orientation_tolerance: float = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Stop() -> Target: ...
    @staticmethod
    def Twist(twist: Twist2) -> Target: ...
    @staticmethod
    def Velocity(velocity: Vector2Like) -> Target: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def satisfied(self, point: Vector2Like) -> bool: ...
    @property
    def valid(self) -> bool: ...

class Twist2:
    angular_speed: float
    frame: Frame
    velocity: Vector2
    def __init__(self, velocity: Vector2Like = ..., angular_speed: float = ..., frame: Frame = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def absolute(self, reference: Pose2) -> Twist2: ...
    def interpolate(self, target: Twist2, time_step: float, max_acceleration: float, max_angular_acceleration: float) -> Twist2: ...
    def is_almost_zero(self, epsilon_speed: float = ..., epsilon_angular_speed: float = ...) -> bool: ...
    def relative(self, reference: Pose2) -> Twist2: ...
    def rotate(self, angle: float) -> Twist2: ...
    def snap_to_zero(self, epsilon: float = ...) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class TwoWheelsDifferentialDriveKinematics(WheeledKinematics):
    max_backward_speed: float
    max_forward_speed: float
    wheel_axis: float
    def __init__(self, max_speed: float = ..., wheel_axis: float = ..., max_angular_speed: float = ..., max_forward_speed: float = ..., max_backward_speed: float = ...) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def can_move_backwards(self) -> bool: ...
    @property
    def can_move_forwards(self) -> bool: ...
    def dof(self) -> int: ...
    def feasible(self, twist: Twist2) -> Twist2: ...
    def twist(self, value: list[float]) -> Twist2: ...
    def wheel_speeds(self, value: Twist2) -> list[float]: ...

class ValuesView:
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def __iter__(self) -> Iterator[Buffer]: ...
    def __len__(self) -> int: ...

class WheeledKinematics(Kinematics):
    # def __init__(self, *args, **kwargs) -> None: ...
    def _pybind11_conduit_v1_(self, *args: Any, **kwargs: Any) -> Any: ...
    def feasible_wheel_speeds(self, value: Twist2) -> list[float]: ...
    @abc.abstractmethod
    def twist(self, value: list[float]) -> Twist2: ...
    @abc.abstractmethod
    def wheel_speeds(self, value: Twist2) -> list[float]: ...

def behavior_has_geometric_state(behavior: Behavior) -> bool: ...
def clamp_norm(vector: Vector2Like, max_length: float) -> Vector2: ...
def get_loaded_plugins() -> dict[str, dict[str, list[str]]]: ...
def load_plugins(plugins: set[os.PathLike[str]] = ..., directories: dict[os.PathLike[str], set[os.PathLike[str]]] = ..., include_default: bool = ...) -> None: ...
def normalize_angle(angle: float) -> float: ...
def orientation_of(vector: Vector2Like) -> float: ...
def rotate(vector: Vector2Like, angle: float) -> Vector2: ...
def bundle_schema() -> dict[str, Any]: ...
def to_absolute(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_absolute_point(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_relative(value: Vector2Like, reference: Pose2) -> Vector2: ...
def to_relative_point(value: Vector2Like, reference: Pose2) -> Vector2: ...
def unit(angle: float) -> Vector2: ...
def uses_doubles() -> bool: ...
def get_build_info() -> BuildInfo: ...
def get_build_dependencies() -> dict[str, DependencyInfo]: ...
def get_plugins_dependencies() -> dict[str, dict[pathlib.Path, dict[str, DependencyInfo]]]: ...
