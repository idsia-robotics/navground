import numpy
import os
from typing import Callable, ClassVar, Iterator, overload, TypeAlias, Literal
Vector2: TypeAlias = numpy.ndarray[tuple[Literal[2]], numpy.dtype[numpy.float64]]
class Action:
    class State:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        failure: ClassVar[Action.State] = ...
        idle: ClassVar[Action.State] = ...
        running: ClassVar[Action.State] = ...
        success: ClassVar[Action.State] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    done_cb: Callable[[Action.State], None] | None
    running_cb: Callable[[float], None] | None
    def __init__(self, *args, **kwargs) -> None: ...
    def abort(self) -> None: ...
    @property
    def done(self) -> bool: ...
    @property
    def running(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class AheadKinematics(Kinematics):
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...

class Behavior(BehaviorRegister, HasProperties):
    class Heading:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        idle: ClassVar[Behavior.Heading] = ...
        target_angle: ClassVar[Behavior.Heading] = ...
        target_angular_speed: ClassVar[Behavior.Heading] = ...
        target_point: ClassVar[Behavior.Heading] = ...
        velocity: ClassVar[Behavior.Heading] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    actuated_twist: Twist2
    angular_speed: float
    assume_cmd_is_actuated: bool
    heading_behavior: Behavior.Heading
    horizon: float
    kinematics: Kinematics
    max_angular_speed: float
    max_speed: float
    optimal_angular_speed: float
    optimal_speed: float
    orientation: float
    path_look_ahead: float
    path_tau: float
    pose: Pose2
    position: Vector2
    radius: float
    rotation_tau: float
    safety_margin: float
    target: Target
    twist: Twist2
    velocity: Vector2
    wheel_speeds: list[float]
    def __init__(self, kinematics: Kinematics | None | None = ..., radius: float = ...) -> None: ...
    @overload
    def actuate(self, twist: Twist2, time_step: float) -> None: ...
    @overload
    def actuate(self, time_step: float) -> None: ...
    def add_modulation(self, value: BehaviorModulation) -> None: ...
    def check_if_target_satisfied(self) -> bool: ...
    def clear_modulations(self) -> None: ...
    def compute_cmd(self, time_step: float, frame: Frame | None = ...) -> Twist2: ...
    def compute_cmd_internal(self, time_step: float, frame: Frame) -> Twist2: ...
    def estimate_time_until_target_satisfied(self) -> float: ...
    def feasible_angular_speed(self, arg0: float) -> float: ...
    def feasible_speed(self, arg0: float) -> float: ...
    @overload
    def feasible_twist(self, value: Twist2, frame: Frame | None = ...) -> Twist2: ...
    @overload
    def feasible_twist(self, value: Twist2, time_step: float, frame: Frame | None = ...) -> Twist2: ...
    def get_actuated_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_environment_state(self) -> EnvironmentState: ...
    def get_target_angular_speed(self) -> float: ...
    def get_target_direction(self, frame: Frame = ...) -> Vector2 | None: ...
    def get_target_distance(self, ignore_tolerance: bool = ...) -> float | None: ...
    def get_target_orientation(self, arg0: Frame) -> float | None: ...
    def get_target_position(self, frame: Frame = ...) -> Vector2 | None: ...
    def get_target_speed(self) -> float: ...
    def get_target_velocity(self, frame: Frame = ...) -> Vector2: ...
    def get_twist(self, frame: Frame = ...) -> Twist2: ...
    def get_velocity(self, frame: Frame = ...) -> Vector2: ...
    def remove_modulation(self, value: BehaviorModulation) -> None: ...
    def set_state_from(self, other: Behavior) -> None: ...
    def set_velocity(self, velocity: Vector2, frame: Frame = ...) -> None: ...
    def to_frame(self, arg0: Twist2, arg1: Frame) -> Twist2: ...
    def twist_from_wheel_speeds(self, arg0: list[float]) -> Twist2: ...
    def wheel_speeds_from_twist(self, arg0: Twist2) -> list[float]: ...
    @property
    def actuated_wheel_speeds(self) -> list[float]: ...
    @property
    def default_cmd_frame(self) -> Frame: ...
    @property
    def desired_velocity(self) -> Vector2: ...
    @property
    def efficacy(self) -> float: ...
    @property
    def environment_state(self) -> EnvironmentState: ...
    @property
    def is_stuck(self) -> bool: ...
    @property
    def modulations(self) -> list[BehaviorModulation]: ...
    @property
    def social_margin(self) -> SocialMargin: ...
    @property
    def type(self) -> str: ...

class BehaviorModulation(BehaviorModulationRegister, HasProperties):
    enabled: bool
    def __init__(self) -> None: ...
    def post(self, behavior: Behavior, time_step: float, cmd: Twist2) -> Twist2: ...
    def pre(self, behavior: Behavior, time_step: float) -> None: ...
    @property
    def type(self) -> str: ...

class BehaviorModulationRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> BehaviorModulation | None: ...

class BehaviorRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Behavior | None: ...

class Buffer:
    categorical: bool
    data: numpy.ndarray
    description: BufferDescription
    high: float
    low: float
    shape: tuple
    type: numpy.dtype
    @overload
    def __init__(self, description: BufferDescription, value: float | float | int | int | int | int | int | int | int | int) -> None: ...
    @overload
    def __init__(self, description: BufferDescription, data: list[float] | list[float] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int]) -> None: ...
    @overload
    def __init__(self, description: BufferDescription) -> None: ...
    @overload
    def __init__(self, data: list[float] | list[float] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int]) -> None: ...
    def set_description(self, arg0: BufferDescription, arg1: bool) -> bool: ...
    @property
    def size(self) -> int: ...

class BufferDescription:
    def __init__(self, shape: list[int], dtype: object = ..., low: float = ..., high: float = ..., categorical: bool = ...) -> None: ...
    @property
    def categorical(self) -> bool: ...
    @property
    def high(self) -> float: ...
    @property
    def low(self) -> float: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def strides(self) -> list[int]: ...
    @property
    def type(self) -> numpy.dtype: ...

class BufferMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> Buffer: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: Buffer) -> None: ...

class CachedCollisionComputation(CollisionComputation):
    length: float
    max_distance: float
    min_angle: float
    resolution: int
    speed: float
    def __init__(self) -> None: ...
    def get_free_distance(self, dynamic: bool) -> list[float]: ...

class CollisionComputation:
    def __init__(self) -> None: ...
    def dynamic_free_distance(self, angle: float, max_distance: float, speed: float) -> float: ...
    def get_angles_for_sector(self, from_angle: float, length: float, resolution: int) -> list[float]: ...
    def get_contour_for_sector(self, from_angle: float, length: float, resolution: int, max_distance: float, dynamic: bool, speed: float = ...) -> list[float]: ...
    def get_free_distance_for_sector(self, from_angle: float, length: float, resolution: int, max_distance: float, dynamic: bool, speed: float = ...) -> list[float]: ...
    def setup(self, pose: Pose2 = ..., margin: float = ..., line_segments: list[LineSegment] = ..., static_discs: list[Disc] = ..., dynamic_discs: list[Neighbor] = ...) -> None: ...
    def static_free_distance(self, angle: float, max_distance: float, include_neighbors: bool = ...) -> float: ...

class Controller:
    behavior: Behavior
    cmd_frame: Frame | None
    speed_tolerance: float
    def __init__(self, behavior: Behavior = ...) -> None: ...
    def follow_direction(self, direction: Vector2) -> Action: ...
    def follow_path(self, path: Path, tolerance: float) -> Action: ...
    def follow_point(self, point: Vector2) -> Action: ...
    def follow_pose(self, pose: Pose2) -> Action: ...
    def follow_twist(self, twist: Twist2) -> Action: ...
    def follow_velocity(self, velocity: Vector2) -> Action: ...
    def go_to_pose(self, pose: Pose2, position_tolerance: float, orientation_tolerance: float, along_path: Path | None = ...) -> Action: ...
    def go_to_position(self, position: Vector2, tolerance: float, along_path: Path | None = ...) -> Action: ...
    def set_cmd_cb(self, callback: Callable[[Twist2], None]) -> None: ...
    def stop(self) -> None: ...
    def update(self, time_step: float) -> Twist2: ...
    @property
    def idle(self) -> bool: ...
    @property
    def state(self) -> Action.State: ...

class Disc:
    position: Vector2
    radius: float
    def __init__(self, position: Vector2, radius: float) -> None: ...
    def distance(self, other: Disc) -> float: ...

class DummyBehavior(Behavior):
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...

class DynamicTwoWheelsDifferentialDriveKinematics(TwoWheelsDifferentialDriveKinematics):
    max_acceleration: float
    max_angular_acceleration: float
    moi: float
    def __init__(self, max_speed: float = ..., axis: float = ..., max_angular_speed: float = ..., max_forward_speed: float = ..., max_backward_speed: float = ..., max_acceleration: float = ..., moi: float = ...) -> None: ...
    def twist_from_wheel_torques(self, values: list[float], current: Twist2, time_step: float) -> Twist2: ...
    def wheel_torques(self, value: Twist2, current: Twist2, time_step: float) -> list[float]: ...
    @property
    def max_wheel_torque(self) -> float: ...

class EnvironmentState:
    def __init__(self, *args, **kwargs) -> None: ...

class FourWheelsOmniDriveKinematics(WheeledKinematics):
    def __init__(self, max_speed: float = ..., axis: float = ...) -> None: ...

class Frame:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    absolute: ClassVar[Frame] = ...
    relative: ClassVar[Frame] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GeometricState(EnvironmentState):
    line_obstacles: list[LineSegment]
    neighbors: list[Neighbor]
    static_obstacles: list[Disc]
    def __init__(self) -> None: ...

class HLBehavior(Behavior):
    aperture: float
    barrier_angle: float
    epsilon: float
    eta: float
    resolution: int
    tau: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    def get_collision_distance(self, arg0: bool, arg1: float | None) -> list[float]: ...
    @property
    def angular_resolution(self) -> float: ...

class HRVOBehavior(Behavior):
    max_number_of_neighbors: int
    uncertainty_offset: float
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...

class HasProperties:
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, name: str) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    def set(self, name: str, value: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]) -> None: ...
    @property
    def properties(self) -> dict[str, Property]: ...

class ItemsView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class KeysView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class Kinematics(KinematicsRegister, HasProperties):
    max_angular_speed: float
    max_speed: float
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...
    @overload
    def feasible(self, twist: Twist2) -> Twist2: ...
    @overload
    def feasible(self, twist: Twist2, current: Twist2, time_step: float) -> Twist2: ...
    @property
    def cmd_frame(self) -> Frame: ...
    @property
    def dof(self) -> int: ...
    @property
    def is_wheeled(self) -> bool: ...
    @property
    def type(self) -> str: ...

class KinematicsRegister:
    type_properties: ClassVar[dict[str, dict[str, Property]]] = ...  # read-only
    types: ClassVar[list[str]] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def _add_properties(arg0: str, arg1: dict[str, Property]) -> None: ...
    @staticmethod
    def _add_property(arg0: str, arg1: str, arg2: object, arg3: bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2], arg4: str, arg5: list[str]) -> None: ...
    @staticmethod
    def _register_type(arg0: str, arg1: object) -> None: ...
    @staticmethod
    def has_type(name: str) -> bool: ...
    @staticmethod
    def make_type(name: str) -> Kinematics | None: ...

class LimitAccelerationModulation(BehaviorModulation):
    max_acceleration: float
    max_angular_acceleration: float
    def __init__(self, max_acceleration: float = ..., max_angular_acceleration: float = ...) -> None: ...

class LimitTwistModulation(BehaviorModulation):
    max_angular_speed: float
    max_backward_speed: float
    max_forward_speed: float
    max_leftward_speed: float
    max_rightward_speed: float
    def __init__(self, forward: float = ..., backward: float = ..., leftward: float = ..., rightward: float = ..., angular: float = ...) -> None: ...

class LineSegment:
    def __init__(self, p1: Vector2, p2: Vector2) -> None: ...
    def distance_along(self, point: Vector2, direction: Vector2, orientation: int = ...) -> float: ...
    def distance_from_disc(self, disc: Disc, penetration: bool = ...) -> float: ...
    def distance_from_point(self, point: Vector2) -> float: ...
    @property
    def e1(self) -> Vector2: ...
    @property
    def e2(self) -> Vector2: ...
    @property
    def length(self) -> float: ...
    @property
    def p1(self) -> Vector2: ...
    @property
    def p2(self) -> Vector2: ...

class MotorPIDModulation(BehaviorModulation):
    k_d: float
    k_i: float
    k_p: float
    def __init__(self, k_p: float = ..., k_i: float = ..., k_d: float = ...) -> None: ...

class Neighbor(Disc):
    id: int
    velocity: Vector2
    def __init__(self, position: Vector2, radius: float, velocity: Vector2 = ..., id: int = ...) -> None: ...
    def relative_to(self, reference: Pose2) -> Neighbor: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class ORCABehavior(Behavior):
    is_using_effective_center: bool
    max_number_of_neighbors: int
    static_time_horizon: float
    time_horizon: float
    treat_obstacles_as_agents: bool
    def __init__(self, kinematics: Kinematics | None = ..., radius: float = ...) -> None: ...
    @property
    def lines(self) -> list[ORCALine]: ...

class ORCALine:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> Vector2: ...
    @property
    def point(self) -> Vector2: ...

class OmnidirectionalKinematics(Kinematics):
    def __init__(self, max_speed: float = ..., max_angular_speed: float = ...) -> None: ...

class Path:
    def __init__(self, project: Callable[[Vector2, float, float], float], curve: Callable[[float], tuple[Vector2, float, float]], length: float, loop: bool = ...) -> None: ...
    def get_point(self, position: Vector2, look_ahead: float = ...) -> tuple[Vector2, float, float]: ...
    def track(self, position: Vector2, look_ahead: float = ...) -> float: ...
    @property
    def coordinate(self) -> float: ...
    @property
    def curve(self) -> Callable[[float], tuple[Vector2, float, float]]: ...
    @property
    def length(self) -> float: ...
    @property
    def loop(self) -> bool: ...
    @property
    def project(self) -> Callable[[Vector2, float, float], float]: ...

class Pose2:
    orientation: float
    position: Vector2
    def __init__(self, position: Vector2, orientation: float = ...) -> None: ...
    def absolute(self, reference: Pose2) -> Pose2: ...
    def integrate(self, twist: Twist2, time_step: float) -> Pose2: ...
    def relative(self, reference: Pose2) -> Pose2: ...
    def rotate(self, angle: float) -> Pose2: ...

class Property:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def default_value(self) -> bool | int | float | str | Vector2 | list[bool] | list[int] | list[float] | list[str] | list[Vector2]: ...
    @property
    def deprecated_names(self) -> list[str]: ...
    @property
    def description(self) -> str: ...
    @property
    def owner_type_name(self) -> str: ...
    @property
    def type_name(self) -> str: ...

class RelaxationModulation(BehaviorModulation):
    tau: float
    def __init__(self, tau: float = ...) -> None: ...

class SensingState(EnvironmentState):
    def __init__(self) -> None: ...
    def get_buffer(self, key: str) -> Buffer: ...
    @overload
    def init_buffer(self, key: str, description: BufferDescription, value: float | float | int | int | int | int | int | int | int | int) -> Buffer: ...
    @overload
    def init_buffer(self, key: str, description: BufferDescription) -> Buffer: ...
    @overload
    def init_buffer(self, key: str, data: list[float] | list[float] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int] | list[int]) -> Buffer: ...
    def set_buffer(self, key: str, buffer: Buffer) -> None: ...
    @property
    def buffers(self) -> BufferMap: ...

class SocialMargin:
    modulation: SocialMarginModulation
    def __init__(self, value: float = ...) -> None: ...
    def get(self, type: int | None = ..., distance: float | None = ...) -> float: ...
    def set(self, value: float, type: int | None = ...) -> None: ...
    @property
    def max_value(self) -> float: ...

class SocialMarginConstantModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class SocialMarginLinearModulation(SocialMarginModulation):
    def __init__(self, upper_distance: float) -> None: ...

class SocialMarginLogisticModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class SocialMarginModulation:
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, margin: float, distance: float | None = ...) -> float: ...

class SocialMarginQuadraticModulation(SocialMarginModulation):
    def __init__(self, upper_distance: float) -> None: ...

class SocialMarginZeroModulation(SocialMarginModulation):
    def __init__(self) -> None: ...

class Target:
    angular_speed: float | None
    direction: Vector2 | None
    orientation: float | None
    orientation_tolerance: float
    path: Path | None
    position: Vector2 | None
    position_tolerance: float
    speed: float | None
    def __init__(self, position: Vector2 | None = ..., orientation: float | None = ..., speed: float | None = ..., direction: Vector2 | None = ..., angular_speed: float | None = ..., path: Path | None = ..., position_tolerance: float = ..., orientation_tolerance: float = ...) -> None: ...
    @staticmethod
    def Direction(direction: Vector2) -> Target: ...
    @staticmethod
    def Orientation(orientation: float, tolerance: float = ...) -> Target: ...
    @staticmethod
    def Point(point: Vector2, tolerance: float = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Pose(pose: Pose2, position_tolerance: float = ..., orientation_tolerance: float = ..., along_path: Path | None = ...) -> Target: ...
    @staticmethod
    def Stop(arg0: Vector2, arg1: float, arg2: Path | None) -> Target: ...
    @staticmethod
    def Twist(twist: Twist2) -> Target: ...
    @staticmethod
    def Velocity(velocity: Vector2) -> Target: ...
    def satisfied(self, arg0: Vector2) -> bool: ...
    @property
    def valid(self) -> bool: ...

class Twist2:
    angular_speed: float
    frame: Frame
    velocity: Vector2
    def __init__(self, velocity: Vector2, angular_speed: float = ..., frame: Frame = ...) -> None: ...
    def absolute(self, reference: Pose2) -> Twist2: ...
    def interpolate(self, target: Twist2, time_step: float, max_acceleration: float, max_angular_acceleration: float) -> Twist2: ...
    def is_almost_zero(self, epsilon_speed: float = ..., epsilon_angular_speed: float = ...) -> bool: ...
    def relative(self, reference: Pose2) -> Twist2: ...
    def rotate(self, angle: float) -> Twist2: ...
    def snap_to_zero(self, epsilon: float = ...) -> None: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class TwoWheelsDifferentialDriveKinematics(WheeledKinematics):
    max_backward_speed: float
    max_forward_speed: float
    def __init__(self, max_speed: float = ..., axis: float = ..., max_angular_speed: float = ..., max_forward_speed: float = ..., max_backward_speed: float = ...) -> None: ...
    @property
    def can_move_backwards(self) -> bool: ...
    @property
    def can_move_forwards(self) -> bool: ...

class ValuesView:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class WheeledKinematics(Kinematics):
    axis: float
    def __init__(self, *args, **kwargs) -> None: ...
    def feasible_wheel_speeds(self, arg0: Twist2) -> list[float]: ...
    def twist(self, arg0: list[float]) -> Twist2: ...
    def wheel_speeds(self, arg0: Twist2) -> list[float]: ...

def behavior_has_geometric_state(arg0: Behavior) -> bool: ...
def clamp_norm(vector: Vector2, max_length: float) -> Vector2: ...
@overload
def dump(behavior: Behavior) -> str: ...
@overload
def dump(kinematics: Kinematics) -> str: ...
@overload
def dump(modulation: BehaviorModulation) -> str: ...
def load_behavior(value: str) -> Behavior | None: ...
def load_behavior_modulation(value: str) -> BehaviorModulation | None: ...
def load_kinematics(value: str) -> Kinematics | None: ...
def load_plugins(plugins: set[os.PathLike] = ..., directories: dict[os.PathLike, set[os.PathLike]] = ..., include_default: bool = ...) -> None: ...
def get_loaded_plugins() -> dict[str, dict[str, list[str]]]: ...
def normalize_angle(angle: float) -> float: ...
def orientation_of(vector: Vector2) -> float: ...
def rotate(vector: Vector2, angle: float) -> Vector2: ...
def to_absolute(value: Vector2, reference: Pose2) -> Vector2: ...
def to_absolute_point(value: Vector2, reference: Pose2) -> Vector2: ...
def to_relative(value: Vector2, reference: Pose2) -> Vector2: ...
def to_relative_point(value: Vector2, reference: Pose2) -> Vector2: ...
def unit(angle: float) -> Vector2: ...
def uses_doubles() -> bool: ...
